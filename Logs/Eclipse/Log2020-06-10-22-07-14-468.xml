<Events startTimestamp="1591841234468" logVersion="1.0.0.202001201631">
  <Command __id="23" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:07:42 EDT 2020" starttimestamp="1591841234468" timestamp="27579" />
  <Command __id="24" _type="ShellCommand" date="Wed Jun 10 22:07:42 EDT 2020" starttimestamp="1591841234468" timestamp="27618" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="25" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:07:42 EDT 2020" starttimestamp="1591841234468" timestamp="27793" />
  <Command __id="26" _type="ShellCommand" date="Wed Jun 10 22:07:49 EDT 2020" starttimestamp="1591841234468" timestamp="35265" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="27" _type="ShellCommand" date="Wed Jun 10 22:07:51 EDT 2020" starttimestamp="1591841234468" timestamp="37048" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="28" _type="ShellCommand" date="Wed Jun 10 22:07:55 EDT 2020" starttimestamp="1591841234468" timestamp="41375" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="29" _type="ShellCommand" date="Wed Jun 10 22:07:56 EDT 2020" starttimestamp="1591841234468" timestamp="42251" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="30" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:07:56 EDT 2020" starttimestamp="1591841234468" timestamp="42285" />
  <Command __id="31" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:07:56 EDT 2020" starttimestamp="1591841234468" timestamp="42358" />
  <Command __id="32" _type="ShellCommand" date="Wed Jun 10 22:07:59 EDT 2020" starttimestamp="1591841234468" timestamp="45040" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="33" _type="ShellCommand" date="Wed Jun 10 22:08:06 EDT 2020" starttimestamp="1591841234468" timestamp="52286" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="34" _type="EclipseCommand" commandID="org.eclipse.ui.file.properties" date="Wed Jun 10 22:08:06 EDT 2020" starttimestamp="1591841234468" timestamp="52314" />
  <Command __id="35" _type="ShellCommand" date="Wed Jun 10 22:08:10 EDT 2020" starttimestamp="1591841234468" timestamp="56114" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="36" _type="ShellCommand" date="Wed Jun 10 22:08:11 EDT 2020" starttimestamp="1591841234468" timestamp="57450" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="37" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.organize.imports" date="Wed Jun 10 22:08:11 EDT 2020" starttimestamp="1591841234468" timestamp="57474" />
  <Command __id="38" _type="ShellCommand" date="Wed Jun 10 22:08:13 EDT 2020" starttimestamp="1591841234468" timestamp="58876" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="41" _type="ShellCommand" date="Wed Jun 10 22:09:23 EDT 2020" starttimestamp="1591841234468" timestamp="129081" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="45" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:09:47 EDT 2020" starttimestamp="1591841234468" timestamp="153491" />
  <Command __id="46" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:09:48 EDT 2020" starttimestamp="1591841234468" timestamp="153554" />
  <Command __id="47" _type="ShellCommand" date="Wed Jun 10 22:09:48 EDT 2020" starttimestamp="1591841234468" timestamp="154309" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="48" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:09:49 EDT 2020" starttimestamp="1591841234468" timestamp="154606" />
  <Command __id="49" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:09:49 EDT 2020" starttimestamp="1591841234468" timestamp="154705" />
  <Command __id="50" _type="ShellCommand" date="Wed Jun 10 22:09:50 EDT 2020" starttimestamp="1591841234468" timestamp="156279" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="51" _type="ShellCommand" date="Wed Jun 10 22:09:54 EDT 2020" starttimestamp="1591841234468" timestamp="159549" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="56" _type="ShellCommand" date="Wed Jun 10 22:10:20 EDT 2020" starttimestamp="1591841234468" timestamp="185732" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="57" _type="ShellCommand" date="Wed Jun 10 22:10:25 EDT 2020" starttimestamp="1591841234468" timestamp="190588" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="58" _type="ShellCommand" date="Wed Jun 10 22:10:42 EDT 2020" starttimestamp="1591841234468" timestamp="207699" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="59" _type="ShellCommand" date="Wed Jun 10 22:10:43 EDT 2020" starttimestamp="1591841234468" timestamp="208741" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="60" _type="ShellCommand" date="Wed Jun 10 22:10:43 EDT 2020" starttimestamp="1591841234468" timestamp="208825" type="ECLIPSE_MINIMIZED" />
  <Command __id="61" _type="ShellCommand" date="Wed Jun 10 22:10:43 EDT 2020" starttimestamp="1591841234468" timestamp="209264" type="ECLIPSE_MAXIMIZED" />
  <Command __id="62" _type="ShellCommand" date="Wed Jun 10 22:10:43 EDT 2020" starttimestamp="1591841234468" timestamp="209305" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63" _type="EclipseCommand" commandID="org.eclipse.ui.file.refresh" date="Wed Jun 10 22:10:48 EDT 2020" starttimestamp="1591841234468" timestamp="213728" />
  <Command __id="64" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:10:48 EDT 2020" starttimestamp="1591841234468" timestamp="213906" />
  <Command __id="65" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:10:48 EDT 2020" starttimestamp="1591841234468" timestamp="214386" />
  <Command __id="0" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:07:14 EDT 2020" docASTNodeCount="45" docActiveCodeLength="385" docExpressionCount="21" docLength="813" projectName="Comp533Final" starttimestamp="1591841234468" timestamp="276">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\Comp533Final\src\DistributedJoinerClass.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[import java.rmi.RemoteException;

public class DistributedJoinerClass extends TokenCountingJoiner implements DistributedJoinerInterface {
//	private int numProcs;
//	private int joinerCount = 0;
	public DistributedJoinerClass(int num) {
//		numProcs = num;
		super(num);
	}
	@Override
	public synchronized void finish(){
		super.finish();
//		joinerCount++;
//		traceJoinerFinishedTask(this, numProcs, joinerCount);
//		if(joinerCount >= numProcs) {
//			notify();
//			joinerCount = 0;
//		}
	}
//
	@Override
	public synchronized void join() {
//		try {
//			traceJoinerWaitStart(this, numProcs, joinerCount); 
//			wait();
//			traceJoinerWaitEnd(this, numProcs, joinerCount); 
//			
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
		super.join();
	}

}
]]></snapshot>
  </Command>
  <Command __id="67" _type="ShellCommand" date="Wed Jun 10 22:10:53 EDT 2020" starttimestamp="1591841234468" timestamp="218639" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="68" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Wed Jun 10 22:10:53 EDT 2020" starttimestamp="1591841234468" timestamp="218690" />
  <Command __id="69" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:10:53 EDT 2020" starttimestamp="1591841234468" timestamp="218697" />
  <Command __id="70" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:10:53 EDT 2020" starttimestamp="1591841234468" timestamp="218780" />
  <Command __id="72" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:10:54 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="220159" />
  <Command __id="73" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:10:56 EDT 2020" starttimestamp="1591841234468" timestamp="221736" />
  <Command __id="74" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:10:56 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="222050" />
  <Command __id="75" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:10:56 EDT 2020" starttimestamp="1591841234468" timestamp="222157" />
  <Command __id="76" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:10:56 EDT 2020" starttimestamp="1591841234468" timestamp="222160" />
  <Command __id="77" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:10:56 EDT 2020" starttimestamp="1591841234468" timestamp="222233" />
  <Command __id="78" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:10:56 EDT 2020" starttimestamp="1591841234468" timestamp="222386" />
  <Command __id="79" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:10:57 EDT 2020" starttimestamp="1591841234468" timestamp="222719" />
  <Command __id="80" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:10:57 EDT 2020" starttimestamp="1591841234468" timestamp="222730" />
  <Command __id="81" _type="ShellCommand" date="Wed Jun 10 22:10:59 EDT 2020" starttimestamp="1591841234468" timestamp="224876" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="82" _type="ShellCommand" date="Wed Jun 10 22:10:59 EDT 2020" starttimestamp="1591841234468" timestamp="225025" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="83" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:10:59 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="225060" />
  <Command __id="85" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:10:59 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="225160" />
  <Command __id="86" _type="MoveCaretCommand" caretOffset="284" date="Wed Jun 10 22:11:02 EDT 2020" docOffset="284" starttimestamp="1591841234468" timestamp="227795" />
  <Command __id="87" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:11:02 EDT 2020" starttimestamp="1591841234468" timestamp="228047" />
  <Command __id="88" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:02 EDT 2020" starttimestamp="1591841234468" timestamp="228114" />
  <Command __id="89" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:02 EDT 2020" starttimestamp="1591841234468" timestamp="228225" />
  <Command __id="91" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:11:03 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="229400" />
  <Command __id="92" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:11:04 EDT 2020" starttimestamp="1591841234468" timestamp="230367" />
  <Command __id="93" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:11:05 EDT 2020" starttimestamp="1591841234468" timestamp="230668" />
  <Command __id="94" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:11:05 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="231037" />
  <Command __id="95" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:05 EDT 2020" starttimestamp="1591841234468" timestamp="231076" />
  <Command __id="96" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:05 EDT 2020" starttimestamp="1591841234468" timestamp="231180" />
  <Command __id="97" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:05 EDT 2020" starttimestamp="1591841234468" timestamp="231385" />
  <Command __id="98" _type="ShellCommand" date="Wed Jun 10 22:11:07 EDT 2020" starttimestamp="1591841234468" timestamp="232971" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="99" _type="ShellCommand" date="Wed Jun 10 22:11:07 EDT 2020" starttimestamp="1591841234468" timestamp="233120" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="100" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:11:07 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="233139" />
  <Command __id="102" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:11:07 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="233212" />
  <Command __id="103" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:11:08 EDT 2020" starttimestamp="1591841234468" timestamp="233592" />
  <Command __id="104" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:08 EDT 2020" starttimestamp="1591841234468" timestamp="234251" />
  <Command __id="105" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:08 EDT 2020" starttimestamp="1591841234468" timestamp="234355" />
  <Command __id="106" _type="ShellCommand" date="Wed Jun 10 22:11:16 EDT 2020" starttimestamp="1591841234468" timestamp="242261" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="71" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:10:54 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6396" docExpressionCount="458" docLength="8991" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="219877">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import java.beans.PropertyChangeEvent;


public abstract class AMapReduceTracer {
	public static String INFO_PREFIX = "";
	public static String WAIT = "wait";
	public static String NOTIFY = "notify";
	public static String ENQUEUE = "enqueue:";
	public static String DEQUEUE = "dequeue:";
	public static String ADD = "add:";
	public static String REDUCE = "reduce:";
	public static String NEW_MAPPER = "new mapper:";
	public static String MODEL = "Model"; // value returned by toString() method of model
	public static String VIEW = "View"; // value returned by toString() method of view
	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller
	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer
	public static final String QUIT = "quit";
	public static final String EXIT = "exit";

	public static final String QUITTING = "Quitting";
	public static final String REGISTER = "Register:";
	public static final String CLIENT_ASSIGNED = "Client Assigned:";

	public static final String REMOTE_LIST = "Remote List:";
	public static final String REMOTE_RESULT = "Remote Result:";


	public static final String START_TOKEN = "Start";
	public static final int BUFFER_SIZE = 2;	


	// -----------------------------A1 Traces----------------------------------
	protected String toPrefix() {
		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";
	}
	protected void trace(String aSuffix) {
		System.out.println(toPrefix() + aSuffix);
	}
	/**
	 * To be called before scanning for input string
	 */
	protected void traceNumbersPrompt() {
		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");
	}
	/**
	 * To be called in the controller and runnable
	 */
	protected void traceQuit() {
		trace (QUITTING);
	}
	/**
	 * To be called in the view at start of call to propertyChange
	 */
	protected void tracePropertyChange(PropertyChangeEvent anEvent) {
		trace(anEvent.toString());
	}
	/*
	 * To be called in the map methods of the mappers before returning
	 */
	public void traceMap(Object anInput, Object aKeyValue) {
		trace (MAP  + anInput + ":" + aKeyValue);		
	}
	/*
	 * To be called in the reducer before returning
	 */
	protected void traceReduce(Object aList,  Object aReducedMap) {
		trace(REDUCE + aList + ":" +  aReducedMap);
	}
	/*
	 * 
	 */
	public static void traceMapperChange(Class aClass, Object aNewMapper) {
		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);
	}
	
	//----------------------------A2 traces -----------------------------------
	/**
	 * To be called before scanning for number of threads
	 */
	protected void traceThreadPrompt() {
		trace("Please enter the number of threads");
	}
	/**
	 * To be called before a wait on this
	 */
	protected void traceWait() {
		trace (WAIT);
	}
	/**
	 * To be called before doing a notify on this 
	 */
	protected void traceNotify() {
		trace(NOTIFY);
	}
//	/**
//	 * To be called by a summer slave thread before adding an int to its sublist 
//	 */
//	protected void traceAdd(int anInt) {
//		trace ( ADD + anInt);
//	}
	/**
	 * To be called by a master thread before adding an element to 
	 * a queue
	 */
	protected void traceEnqueueRequest(Object anElement) {
		trace(ENQUEUE + anElement);
	}
	/**
	 * To be called by a  master thread after adding an object to 
	 * a queue
	 */
	protected void traceEnqueue(Object aQueue) {
		trace(ENQUEUE + aQueue);
	}
	/**
	 * To be called by a slave thread before executing a take from
	 * queue 
	 */
	protected void traceDequeueRequest(Object aQueue) {
		trace (DEQUEUE + aQueue);
	}
	/**
	 * To be called by a slave thread after taking an object from a
	 * queue 
	 */
	protected void traceDequeue(Object anElement) {
		trace (DEQUEUE + anElement);
	}
	
//	/**
//	 * To be called in the model at the start of its reduce method	 
//	 */
//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {
//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);
//	}
	
	
	/*
	 * Additions since assignment was last given
	 */
	public static final String BARRIER_CREATED = "Barrier Created:";
	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; 
	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; 
	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; 
	
	public static final String JOINER_CREATED = "Joiner Created:";
	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; 
	public static final String JOINER_WAIT_END = "Joiner Wait End:"; 
	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; 
	public static final String JOINER_RELEASE = "Joiner Release:"; 	
	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; 
	public static final String MAP = "Map:";
//	public static final String REDUCE = "Reduce:";

	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";
	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	
	
	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {
		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		
	}
	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {
		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		
	}
	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {
		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		
	}
	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {
		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		
	}
	
	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {
		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		
	}
	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {
		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		
	}
	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {
		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		
	}
	/*
	 * Call after changing finished threads in the joiner
	 */
	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {
		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		
	}
	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {
		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		
	}
	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {
		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );
	}
	/*
	 * To be printed by thread aThreadNumber
	 */
	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {
		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);
	}
	
	
	/*
	 * Call after adding reduced map to final map
	 */
	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {
		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);
	}
	
	//---------------------------A3 Traces--------------------------------------
	/**
	 * To be called in the server at the start of its method for registering a client
	 */
	protected void traceRegister(Object aClient) {
		trace (REGISTER + aClient);
	}
	/**
	 * To be called in the server runnable when it is assigned a  client
	 */
	protected void traceClientAssignment(Object aClient) {
		trace(CLIENT_ASSIGNED + aClient);
	}	
	
	/**
	 * To be called in the server runnable before invoking the callback in the client.
	 * To be also called in the client at the start of its callback to process sublist	 * 
	 */
	public void traceRemoteList (Object aSublist) {
		trace (REMOTE_LIST + aSublist);
	}
	/**
	 * To be called in the client before returning its result.
	 * To be also called in server runnable after receiving the result from the client
	 */
	public void traceRemoteResult (Object aResult) {
		trace (REMOTE_RESULT + aResult);
	}
	/**
	 * Static method be called by the client main method
	 */
	public static void traceExit(Class aClass) {
		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);
	}
	
	/**
	 * Slave runnables and client objects can define the following two methods
	 */
	public synchronized void synchronizedNotify() {
		traceNotify();
		this.notify();
	}	
	public synchronized void synchronizedWait() throws InterruptedException {
		traceWait();		
		this.wait();
		
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="84" _type="Replace" date="Wed Jun 10 22:10:59 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" endLine="0" insertionLength="3" int_docASTNodeCount="930" int_docActiveCodeLength="6389" int_docExpressionCount="457" int_docLength="8984" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="225101">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="90" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:11:03 EDT 2020" docASTNodeCount="44" docActiveCodeLength="333" docExpressionCount="26" docLength="333" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="229178">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\DistributedClient.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import java.rmi.Remote;
import java.rmi.RemoteException;
import util.interactiveMethodInvocation.IPCMechanism;

public interface DistributedClient extends Remote{
	public void updateCommand(String command) throws RemoteException;
	public void setIPCMetaState(IPCMechanism value) throws RemoteException;
}
]]></snapshot>
  </Command>
  <DocumentChange __id="101" _type="Replace" date="Wed Jun 10 22:11:07 EDT 2020" docASTNodeCount="44" docActiveCodeLength="329" docExpressionCount="26" docLength="329" endLine="0" insertionLength="3" int_docASTNodeCount="42" int_docActiveCodeLength="326" int_docExpressionCount="25" int_docLength="326" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="233143">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="107" _type="ShellCommand" date="Wed Jun 10 22:11:38 EDT 2020" starttimestamp="1591841234468" timestamp="263980" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="108" _type="EclipseCommand" commandID="org.eclipse.ui.file.properties" date="Wed Jun 10 22:11:38 EDT 2020" starttimestamp="1591841234468" timestamp="264005" />
  <Command __id="109" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:39 EDT 2020" starttimestamp="1591841234468" timestamp="264972" />
  <Command __id="110" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:39 EDT 2020" starttimestamp="1591841234468" timestamp="265478" />
  <Command __id="112" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:11:42 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="267718" />
  <Command __id="111" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:11:42 EDT 2020" docASTNodeCount="40" docActiveCodeLength="330" docExpressionCount="21" docLength="330" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="267536">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\DistributedConsensusClient.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import java.rmi.RemoteException;

import consensus.ProposalFeedbackKind;

public interface DistributedConsensusClient extends DistributedClient {
	public void setBroadcastMode(boolean value) throws RemoteException;
	public ProposalFeedbackKind accept(String name, Object val) throws RemoteException;
}
]]></snapshot>
  </Command>
  <DocumentChange __id="126" _type="Replace" date="Wed Jun 10 22:11:46 EDT 2020" docASTNodeCount="40" docActiveCodeLength="326" docExpressionCount="21" docLength="326" endLine="0" insertionLength="3" int_docASTNodeCount="38" int_docActiveCodeLength="323" int_docExpressionCount="20" int_docLength="323" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="272392">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="131" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:11:48 EDT 2020" docASTNodeCount="44" docActiveCodeLength="329" docExpressionCount="26" docLength="329" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="274021">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\DistributedClient.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com"), Diff(DELETE,"p533"), Diff(EQUAL,";¶¶import java.rmi.Remote;¶import java.rmi.RemoteException;¶import util.interactiveMethodInvocation.IPCMechanism;¶¶public interface DistributedClient extends Remote{¶	public void updateCommand(String command) throws RemoteException;¶	public void setIPCMetaState(IPCMechanism value) throws RemoteException;¶}¶")]]]></diff>
    <snapshot><![CDATA[package com;

import java.rmi.Remote;
import java.rmi.RemoteException;
import util.interactiveMethodInvocation.IPCMechanism;

public interface DistributedClient extends Remote{
	public void updateCommand(String command) throws RemoteException;
	public void setIPCMetaState(IPCMechanism value) throws RemoteException;
}
]]></snapshot>
  </Command>
  <Command __id="113" _type="SelectTextCommand" caretOffset="5" date="Wed Jun 10 22:11:43 EDT 2020" end="18" start="5" starttimestamp="1591841234468" timestamp="268755" />
  <Command __id="114" _type="MoveCaretCommand" caretOffset="9" date="Wed Jun 10 22:11:43 EDT 2020" docOffset="9" starttimestamp="1591841234468" timestamp="268984" />
  <Command __id="115" _type="MoveCaretCommand" caretOffset="15" date="Wed Jun 10 22:11:44 EDT 2020" docOffset="15" starttimestamp="1591841234468" timestamp="269732" />
  <Command __id="116" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:11:45 EDT 2020" starttimestamp="1591841234468" timestamp="270550" />
  <Command __id="117" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:11:45 EDT 2020" starttimestamp="1591841234468" timestamp="270861" />
  <Command __id="118" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:11:45 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="271054" />
  <Command __id="119" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:45 EDT 2020" starttimestamp="1591841234468" timestamp="271096" />
  <Command __id="120" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:45 EDT 2020" starttimestamp="1591841234468" timestamp="271196" />
  <Command __id="121" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:45 EDT 2020" starttimestamp="1591841234468" timestamp="271374" />
  <Command __id="122" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:46 EDT 2020" starttimestamp="1591841234468" timestamp="271538" />
  <Command __id="123" _type="ShellCommand" date="Wed Jun 10 22:11:46 EDT 2020" starttimestamp="1591841234468" timestamp="272152" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="124" _type="ShellCommand" date="Wed Jun 10 22:11:46 EDT 2020" starttimestamp="1591841234468" timestamp="272368" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="125" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:11:46 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="272389" />
  <Command __id="127" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:11:46 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="272454" />
  <Command __id="128" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:11:47 EDT 2020" starttimestamp="1591841234468" timestamp="272832" />
  <Command __id="129" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:47 EDT 2020" starttimestamp="1591841234468" timestamp="273500" />
  <Command __id="130" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:48 EDT 2020" starttimestamp="1591841234468" timestamp="273588" />
  <Command __id="132" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:11:48 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="274187" />
  <Command __id="134" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:11:51 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="276891" />
  <Command __id="135" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:11:52 EDT 2020" starttimestamp="1591841234468" timestamp="277604" />
  <Command __id="136" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:11:52 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="277933" />
  <Command __id="137" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:52 EDT 2020" starttimestamp="1591841234468" timestamp="277964" />
  <Command __id="138" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:11:52 EDT 2020" starttimestamp="1591841234468" timestamp="277966" />
  <Command __id="139" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:52 EDT 2020" starttimestamp="1591841234468" timestamp="278286" />
  <Command __id="140" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:52 EDT 2020" starttimestamp="1591841234468" timestamp="278464" />
  <Command __id="141" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:53 EDT 2020" starttimestamp="1591841234468" timestamp="278631" />
  <Command __id="142" _type="ShellCommand" date="Wed Jun 10 22:11:54 EDT 2020" starttimestamp="1591841234468" timestamp="279930" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="143" _type="ShellCommand" date="Wed Jun 10 22:11:54 EDT 2020" starttimestamp="1591841234468" timestamp="280091" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="144" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:11:54 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="280128" />
  <Command __id="146" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:11:54 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="280177" />
  <Command __id="147" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:11:55 EDT 2020" starttimestamp="1591841234468" timestamp="280568" />
  <Command __id="149" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:55 EDT 2020" starttimestamp="1591841234468" timestamp="281282" />
  <Command __id="150" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:11:55 EDT 2020" starttimestamp="1591841234468" timestamp="281369" />
  <Command __id="151" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:11:55 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="281444" />
  <Command __id="153" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:11:57 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="282575" />
  <Command __id="154" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:11:57 EDT 2020" starttimestamp="1591841234468" timestamp="283461" />
  <Command __id="155" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:11:58 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="283792" />
  <Command __id="156" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:11:58 EDT 2020" starttimestamp="1591841234468" timestamp="283848" />
  <Command __id="157" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:11:58 EDT 2020" starttimestamp="1591841234468" timestamp="283849" />
  <Command __id="133" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:11:51 EDT 2020" docASTNodeCount="76" docActiveCodeLength="598" docExpressionCount="41" docLength="598" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="276730">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\DistributedConsensusServer.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import java.rmi.RemoteException;

import util.interactiveMethodInvocation.ConsensusAlgorithm;
import util.interactiveMethodInvocation.IPCMechanism;

public interface DistributedConsensusServer extends DistributedServer {
	public void join(String clientName, DistributedConsensusClient client, IPCMechanism value) throws RemoteException;
	public void broadcastBroadcastMode(String clientName, boolean value) throws RemoteException;
	public void broadcast(String clientName, String newCommand, IPCMechanism value, ConsensusAlgorithm algorithm) throws RemoteException;
}
]]></snapshot>
  </Command>
  <DocumentChange __id="145" _type="Replace" date="Wed Jun 10 22:11:54 EDT 2020" docASTNodeCount="76" docActiveCodeLength="594" docExpressionCount="41" docLength="594" endLine="0" insertionLength="3" int_docASTNodeCount="74" int_docActiveCodeLength="591" int_docExpressionCount="40" int_docLength="591" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="280132">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="148" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:11:55 EDT 2020" docASTNodeCount="44" docActiveCodeLength="329" docExpressionCount="26" docLength="329" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="281278">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\DistributedClient.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.rmi.Remote;¶import java.rmi.RemoteException;¶import util.interactiveMethodInvocation.IPCMechanism;¶¶public interface DistributedClient extends Remote{¶	public void updateCommand(String command) throws RemoteException;¶	public void setIPCMetaState(IPCMechanism value) throws RemoteException;¶}¶")]]]></diff>
  </Command>
  <Command __id="152" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:11:56 EDT 2020" docASTNodeCount="56" docActiveCodeLength="395" docExpressionCount="32" docLength="503" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="282338">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\DistributedServer.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import java.rmi.Remote;
import java.rmi.RemoteException;
import util.interactiveMethodInvocation.IPCMechanism;

public interface DistributedServer extends Remote{
//	public void join(String clientName, DistributedClient client, IPCMechanism value) throws RemoteException;
	public void broadcast(String clientName, String command, IPCMechanism value) throws RemoteException;
	public void broadcastIPCMetaState(String clientName, IPCMechanism value) throws RemoteException;
}
]]></snapshot>
  </Command>
  <DocumentChange __id="161" _type="Replace" date="Wed Jun 10 22:11:59 EDT 2020" docASTNodeCount="56" docActiveCodeLength="391" docExpressionCount="32" docLength="499" endLine="0" insertionLength="3" int_docASTNodeCount="54" int_docActiveCodeLength="388" int_docExpressionCount="31" int_docLength="496" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="285031">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="166" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:01 EDT 2020" docASTNodeCount="44" docActiveCodeLength="329" docExpressionCount="26" docLength="329" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="286750">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\DistributedClient.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.rmi.Remote;¶import java.rmi.RemoteException;¶import util.interactiveMethodInvocation.IPCMechanism;¶¶public interface DistributedClient extends Remote{¶	public void updateCommand(String command) throws RemoteException;¶	public void setIPCMetaState(IPCMechanism value) throws RemoteException;¶}¶")]]]></diff>
  </Command>
  <Command __id="158" _type="ShellCommand" date="Wed Jun 10 22:11:59 EDT 2020" starttimestamp="1591841234468" timestamp="284850" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="159" _type="ShellCommand" date="Wed Jun 10 22:11:59 EDT 2020" starttimestamp="1591841234468" timestamp="285006" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="160" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:11:59 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="285026" />
  <Command __id="162" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:11:59 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="285093" />
  <Command __id="163" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:11:59 EDT 2020" starttimestamp="1591841234468" timestamp="285531" />
  <Command __id="164" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:12:00 EDT 2020" starttimestamp="1591841234468" timestamp="286240" />
  <Command __id="165" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:12:00 EDT 2020" starttimestamp="1591841234468" timestamp="286318" />
  <Command __id="167" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:12:01 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="286890" />
  <Command __id="169" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:12:02 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="288522" />
  <Command __id="170" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:12:04 EDT 2020" starttimestamp="1591841234468" timestamp="289684" />
  <Command __id="171" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:12:04 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="289996" />
  <Command __id="172" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:12:04 EDT 2020" starttimestamp="1591841234468" timestamp="290029" />
  <Command __id="173" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:12:04 EDT 2020" starttimestamp="1591841234468" timestamp="290032" />
  <Command __id="174" _type="ShellCommand" date="Wed Jun 10 22:12:05 EDT 2020" starttimestamp="1591841234468" timestamp="291125" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="175" _type="ShellCommand" date="Wed Jun 10 22:12:05 EDT 2020" starttimestamp="1591841234468" timestamp="291297" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="176" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:12:05 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="291327" />
  <Command __id="178" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:12:05 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="291372" />
  <Command __id="179" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:12:06 EDT 2020" starttimestamp="1591841234468" timestamp="291629" />
  <Command __id="181" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:12:06 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="292096" />
  <Command __id="182" _type="ShellCommand" date="Wed Jun 10 22:12:06 EDT 2020" starttimestamp="1591841234468" timestamp="292500" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="183" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:12:06 EDT 2020" starttimestamp="1591841234468" timestamp="292501" />
  <Command __id="184" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:12:07 EDT 2020" starttimestamp="1591841234468" timestamp="292749" />
  <Command __id="185" _type="ShellCommand" date="Wed Jun 10 22:12:46 EDT 2020" starttimestamp="1591841234468" timestamp="332439" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="186" _type="MoveCaretCommand" caretOffset="240" date="Wed Jun 10 22:12:48 EDT 2020" docOffset="329" starttimestamp="1591841234468" timestamp="333659" />
  <Command __id="188" _type="MoveCaretCommand" caretOffset="284" date="Wed Jun 10 22:12:48 EDT 2020" docOffset="284" starttimestamp="1591841234468" timestamp="334200" />
  <Command __id="190" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:12:49 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="335142" />
  <Command __id="168" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:02 EDT 2020" docASTNodeCount="1706" docActiveCodeLength="12521" docExpressionCount="1185" docLength="13028" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="288326">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\HalloweenClient.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.concurrent.ArrayBlockingQueue;

import assignments.util.MiscAssignmentUtils;
import assignments.util.inputParameters.AnAbstractSimulationParametersBean;
import assignments.util.mainArgs.ClientArgsProcessor;
import consensus.ProposalFeedbackKind;
import coupledsims.Simulation;
import coupledsims.Simulation1;
import coupledsims.StandAloneTwoCoupledHalloweenSimulations;
import inputport.nio.manager.NIOManager;
import inputport.nio.manager.NIOManagerFactory;
import inputport.nio.manager.factories.classes.AConnectCommandFactory;
import inputport.nio.manager.factories.selectors.ConnectCommandFactorySelector;
import inputport.rpc.ACachingAbstractRPCProxyInvocationHandler;
import inputport.rpc.GIPCLocateRegistry;
import inputport.rpc.GIPCRegistry;
import main.BeauAndersonFinalProject;
import port.ATracingConnectionListener;
import stringProcessors.HalloweenCommandProcessor;
import util.interactiveMethodInvocation.ConsensusAlgorithm;
import util.interactiveMethodInvocation.IPCMechanism;
import util.interactiveMethodInvocation.SimulationParametersControllerFactory;
import util.misc.ThreadSupport;
import util.trace.TooManyTracesException;
import util.trace.Tracer;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.PerformanceExperimentEnded;
import util.trace.port.PerformanceExperimentStarted;
import util.trace.port.PortTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.consensus.ProposalAcceptRequestReceived;
import util.trace.port.consensus.ProposalAcceptedNotificationSent;
import util.trace.port.consensus.ProposalLearnedNotificationReceived;
import util.trace.port.consensus.ProposalMade;
import util.trace.port.consensus.ProposedStateSet;
import util.trace.port.consensus.RemoteProposeRequestSent;
import util.trace.port.consensus.communication.CommunicationStateNames;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;
import util.trace.port.rpc.rmi.RMIObjectLookedUp;
import util.trace.port.rpc.rmi.RMIRegistryLocated;
import util.trace.port.rpc.rmi.RMITraceUtility;


public class HalloweenClient extends AnAbstractSimulationParametersBean implements DistributedConsensusClient, NIOClient,
												StandAloneTwoCoupledHalloweenSimulations, PropertyChangeListener{
	protected int NUM_EXPERIMENT_COMMANDS = 500;
	public static final String EXPERIMENT_COMMAND_1 = "move 1 -1";
	public static final String EXPERIMENT_COMMAND_2 = "undo";
	private HalloweenCommandProcessor commandProcessor;
	
	private DistributedConsensusServer server;
	private DistributedConsensusServer GIPCServer;
	private DistributedConsensusServer currentServer;
	private String registryHost;
	private int registryPort;
	private String serverHost;
	private String clientName;
	private String headless;
	private int GIPCPort;
	private int NIOPort;
	
	
	protected NIOManager nioManager = NIOManagerFactory.getSingleton();
	protected SocketChannel socketChannel;
	
	
	private final static int BUFFER_SIZE = 512;
	public static final String READ_THREAD_NAME = "Read Thread";
	private ArrayBlockingQueue<Message> bufferQueue = new ArrayBlockingQueue<>(BUFFER_SIZE);
	private Thread readThread;
	
	protected void setTracing() {
		PortTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		FactoryTraceUtility.setTracing();		
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		GIPCRPCTraceUtility.setTracing();
		trace(true);
	}
	
	void processArgs(String[] args) {	
		registryHost = ClientArgsProcessor.getRegistryHost(args);
		registryPort = ClientArgsProcessor.getRegistryPort(args);
		serverHost = ClientArgsProcessor.getServerHost(args);
		headless = ClientArgsProcessor.getHeadless(args);
		clientName = ClientArgsProcessor.getClientName(args);
		GIPCPort = ClientArgsProcessor.getGIPCPort(args);
		NIOPort = ClientArgsProcessor.getNIOServerPort(args);
		// Make sure you set this property when processing args
		System.setProperty("java.awt.headless", headless);
		
	}
	
	protected void setFactories() {		
		ConnectCommandFactorySelector.setFactory(new AConnectCommandFactory(SelectionKey.OP_READ));
	}
	
	protected void init(String[] args) {
		setTracing();
		setFactories();
		processArgs(args);
		commandProcessor = BeauAndersonFinalProject.createSimulation(
						   Simulation1.SIMULATION1_PREFIX,
						   Simulation1.SIMULATION1_X_OFFSET, 
						   Simulation.SIMULATION_Y_OFFSET, 
						   Simulation.SIMULATION_WIDTH, 
						   Simulation.SIMULATION_HEIGHT, 
						   Simulation1.SIMULATION1_X_OFFSET, 
						   Simulation.SIMULATION_Y_OFFSET);
		commandProcessor.addPropertyChangeListener(this);
	}

	@Override
	public void start(String[] args) {
		init(args);
		// register a callback to process actions denoted by the user commands
		ACachingAbstractRPCProxyInvocationHandler.setInvokeObjectMethodsRemotely(false);
		try {
			Registry rmiRegistry = LocateRegistry.getRegistry(registryPort);
			RMIRegistryLocated.newCase(this, registryHost, registryPort, rmiRegistry);
			UnicastRemoteObject.exportObject(this, 0);
			server = (DistributedConsensusServer) rmiRegistry.lookup(DistributedConsensusServer.class.getName());
			RMIObjectLookedUp.newCase(this, server, DistributedServer.class.getName(), rmiRegistry);
			server.join(clientName, this, IPCMechanism.RMI);
			
			GIPCRegistry gipcRegistry = GIPCLocateRegistry.getRegistry(serverHost, GIPCPort, clientName);
			GIPCServer = (DistributedConsensusServer) gipcRegistry.lookup(DistributedConsensusServer.class, "GIPCServer");
			GIPCServer.join(clientName, this, IPCMechanism.GIPC);
			gipcRegistry.getInputPort().addConnectionListener(new ATracingConnectionListener(gipcRegistry.getInputPort()));
			currentServer = GIPCServer;
			
			socketChannel = SocketChannel.open();
			InetAddress aServerAddress = InetAddress.getByName(serverHost);
			nioManager.connect(socketChannel, aServerAddress, NIOPort, this);
			
			
		} catch (Exception e) {
			e.printStackTrace();
		}		
		this.setBroadcastMetaState(true);
		SimulationParametersControllerFactory.getSingleton().addSimulationParameterListener(this);
		SimulationParametersControllerFactory.getSingleton().processCommands();		
	}

	
	@Override	
	public void quit(int aCode) {
		readThread.interrupt();
		System.exit(aCode);
	}	
	@Override
	/*
	 * You will need to delay not command input but sends(non-Javadoc)
	 */
	public void simulationCommand(String aCommand) {
		long aDelay = getDelay(); 
		if (aDelay > 0) {
			ThreadSupport.sleep(aDelay);
		}
		ProposalMade.newCase(this, CommunicationStateNames.COMMAND, -1, aCommand);
		commandProcessor.setInputString(aCommand); 
	}
	@Override	
	public void trace(boolean newValue) {
		super.trace(newValue);
		Tracer.showInfo(isTrace());
	}
	@Override
	public void localProcessingOnly(boolean newValue) {
		super.localProcessingOnly(newValue);
	}
	@Override
	/**
	 * Relevant in consistency assignments only 
	 */
	public void atomicBroadcast(boolean newValue) {
		super.atomicBroadcast(newValue);
		commandProcessor.setConnectedToSimulation(!isAtomicBroadcast());
		if(isBroadcastMetaState())
		{
			try {
				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
				server.broadcastBroadcastMode(clientName, newValue);
			} catch (RemoteException e) {
				e.printStackTrace();
			} catch (TooManyTracesException e) {
				e.printStackTrace();
			}
		}
		
	}
	@Override
	public void experimentInput() {
		long aStartTime = System.currentTimeMillis();
		PerformanceExperimentStarted.newCase(this, aStartTime, NUM_EXPERIMENT_COMMANDS);
		boolean anOldValue = isTrace();
		this.trace(false);
		for (int i = 0; i < NUM_EXPERIMENT_COMMANDS; i++) {
			commandProcessor.setInputString(EXPERIMENT_COMMAND_1);
			commandProcessor.setInputString(EXPERIMENT_COMMAND_2);
		}
		trace(anOldValue);
		long anEndTime = System.currentTimeMillis();
		PerformanceExperimentEnded.newCase(this, aStartTime, anEndTime, anEndTime - aStartTime, NUM_EXPERIMENT_COMMANDS);
		
	}
	@Override
	/*
	 * This override is not really needed, provided here to show that this method
	 * exists.
	 */
	public void delaySends(int aMillisecondDelay) {
		// invoke setDelaySends so getDelaySends can be used to determine the delay
		// in other parts of the program
		super.delaySends(aMillisecondDelay);
	}


	@Override
	public void updateCommand(String newCommand) {
		ProposalLearnedNotificationReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
		commandProcessor.processCommand(newCommand);
		ProposedStateSet.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
	}

	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		try {
			if (evt.getPropertyName().equals("InputString")){
				if(isLocalProcessingOnly()) return;
				String newCommand = (String) evt.getNewValue();
				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
				if(ipcMechanism == IPCMechanism.NIO) {
					nioManager.write(socketChannel, ByteBuffer.wrap(newCommand.getBytes()), this);
				}
				else {
					currentServer.broadcast(clientName, newCommand, ipcMechanism, this.consensusAlgorithm);
				}
			}
		} catch (RemoteException e) {
			e.printStackTrace();
		} catch (TooManyTracesException e) {
			e.printStackTrace();
		}
	}
	@Override
	public void consensusAlgorithm(ConsensusAlgorithm newVal) {
		this.consensusAlgorithm = newVal;
		if(newVal == ConsensusAlgorithm.CENTRALIZED_SYNCHRONOUS) this.atomicBroadcast(true);
	}
	
	@Override
	public void ipcMechanism(IPCMechanism newValue) {
		super.ipcMechanism(newValue);
		changeIPC(newValue);
		if(isBroadcastMetaState())
		{
			try {
				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
				server.broadcastIPCMetaState(clientName, newValue);
			} catch (RemoteException e) {
				e.printStackTrace();
			} catch (TooManyTracesException e) {
				e.printStackTrace();
			}
		}
	}
	
	public void changeIPC(IPCMechanism newValue) {
		switch(newValue) {
			case RMI:
				currentServer = server;
				return;
			case GIPC:
				currentServer = GIPCServer;
				return;
			case NIO:
				return ;
		}
	}
	@Override
	public void setIPCMetaState(IPCMechanism value) {
		ProposalLearnedNotificationReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, value);
		setIPCMechanism(value);
		changeIPC(value);
	}

	@Override
	public void connected(SocketChannel aSocketChannel) {
		nioManager.addReadListener(aSocketChannel, this);
		readThread = new Thread(new ReadSlave(this));
		readThread.setName(READ_THREAD_NAME);
		readThread.start();
	}
	@Override
	public void notConnected(SocketChannel theSocketChannel, Exception e) {
		
	}
	@Override
	public void written(SocketChannel socketChannel, ByteBuffer theWriteBuffer, int sendId) {
		
	}
	@Override
	public void socketChannelRead(SocketChannel aSocketChannel, ByteBuffer aMessage, int aLength) {
		if(!bufferQueue.add(new Message(aSocketChannel, MiscAssignmentUtils.deepDuplicate(aMessage), aLength))) {
			System.out.println("Buffer is full!");
		}
	}

	@Override
	public void finishRead(Message message){
		String newCommand = new String(message.getBuffer().array(), message.getBuffer().position(), message.getLength());
		updateCommand(newCommand);
	}

	@Override
	public ArrayBlockingQueue<Message> getBufferQueue() {
		return this.bufferQueue;
	}

	@Override
	public void setBroadcastMode(boolean value) {
		ProposalLearnedNotificationReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, value);
		setAtomicBroadcast(value);
		commandProcessor.setConnectedToSimulation(!isAtomicBroadcast());
	}

	@Override
	public ProposalFeedbackKind accept(String name, Object val) {
		ProposalAcceptRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, val);
		ProposalFeedbackKind feedback = ProposalFeedbackKind.SERVICE_DENIAL;
		if(name.equals(CommunicationStateNames.COMMAND)) {	
//			commandProcessor.processCommand("");
			feedback = ProposalFeedbackKind.SUCCESS;
		}
		ProposalAcceptedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, val, feedback);
		return feedback;
	}
	
}
]]></snapshot>
  </Command>
  <DocumentChange __id="177" _type="Replace" date="Wed Jun 10 22:12:05 EDT 2020" docASTNodeCount="1706" docActiveCodeLength="12517" docExpressionCount="1185" docLength="13024" endLine="0" insertionLength="3" int_docASTNodeCount="1704" int_docActiveCodeLength="12514" int_docExpressionCount="1184" int_docLength="13021" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="291342">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="180" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:06 EDT 2020" docASTNodeCount="44" docActiveCodeLength="329" docExpressionCount="26" docLength="329" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="291901">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\DistributedClient.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.rmi.Remote;¶import java.rmi.RemoteException;¶import util.interactiveMethodInvocation.IPCMechanism;¶¶public interface DistributedClient extends Remote{¶	public void updateCommand(String command) throws RemoteException;¶	public void setIPCMetaState(IPCMechanism value) throws RemoteException;¶}¶")]]]></diff>
  </Command>
  <Command __id="187" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:48 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="333951">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com"), Diff(DELETE,"p533"), Diff(EQUAL,";¶¶import java.beans.PropertyChangeEvent;¶¶¶public abstract class AMapReduceTracer {¶	public static String INFO_PREFIX = "";¶	public static String WAIT = "wait";¶	public static String NOTIFY = "notify";¶	public static String ENQUEUE = "enqueue:";¶	public static String DEQUEUE = "dequeue:";¶	public static String ADD = "add:";¶	public static String REDUCE = "reduce:";¶	public static String NEW_MAPPER = "new mapper:";¶	public static String MODEL = "Model"; // value returned by toString() method of model¶	public static String VIEW = "View"; // value returned by toString() method of view¶	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller¶	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer¶	public static final String QUIT = "quit";¶	public static final String EXIT = "exit";¶¶	public static final String QUITTING = "Quitting";¶	public static final String REGISTER = "Register:";¶	public static final String CLIENT_ASSIGNED = "Client Assigned:";¶¶	public static final String REMOTE_LIST = "Remote List:";¶	public static final String REMOTE_RESULT = "Remote Result:";¶¶¶	public static final String START_TOKEN = "Start";¶	public static final int BUFFER_SIZE = 2;	¶¶¶	// -----------------------------A1 Traces----------------------------------¶	protected String toPrefix() {¶		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";¶	}¶	protected void trace(String aSuffix) {¶		System.out.println(toPrefix() + aSuffix);¶	}¶	/**¶	 * To be called before scanning for input string¶	 */¶	protected void traceNumbersPrompt() {¶		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");¶	}¶	/**¶	 * To be called in the controller and runnable¶	 */¶	protected void traceQuit() {¶		trace (QUITTING);¶	}¶	/**¶	 * To be called in the view at start of call to propertyChange¶	 */¶	protected void tracePropertyChange(PropertyChangeEvent anEvent) {¶		trace(anEvent.toString());¶	}¶	/*¶	 * To be called in the map methods of the mappers before returning¶	 */¶	public void traceMap(Object anInput, Object aKeyValue) {¶		trace (MAP  + anInput + ":" + aKeyValue);		¶	}¶	/*¶	 * To be called in the reducer before returning¶	 */¶	protected void traceReduce(Object aList,  Object aReducedMap) {¶		trace(REDUCE + aList + ":" +  aReducedMap);¶	}¶	/*¶	 * ¶	 */¶	public static void traceMapperChange(Class aClass, Object aNewMapper) {¶		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);¶	}¶	¶	//----------------------------A2 traces -----------------------------------¶	/**¶	 * To be called before scanning for number of threads¶	 */¶	protected void traceThreadPrompt() {¶		trace("Please enter the number of threads");¶	}¶	/**¶	 * To be called before a wait on this¶	 */¶	protected void traceWait() {¶		trace (WAIT);¶	}¶	/**¶	 * To be called before doing a notify on this ¶	 */¶	protected void traceNotify() {¶		trace(NOTIFY);¶	}¶//	/**¶//	 * To be called by a summer slave thread before adding an int to its sublist ¶//	 */¶//	protected void traceAdd(int anInt) {¶//		trace ( ADD + anInt);¶//	}¶	/**¶	 * To be called by a master thread before adding an element to ¶	 * a queue¶	 */¶	protected void traceEnqueueRequest(Object anElement) {¶		trace(ENQUEUE + anElement);¶	}¶	/**¶	 * To be called by a  master thread after adding an object to ¶	 * a queue¶	 */¶	protected void traceEnqueue(Object aQueue) {¶		trace(ENQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread before executing a take from¶	 * queue ¶	 */¶	protected void traceDequeueRequest(Object aQueue) {¶		trace (DEQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread after taking an object from a¶	 * queue ¶	 */¶	protected void traceDequeue(Object anElement) {¶		trace (DEQUEUE + anElement);¶	}¶	¶//	/**¶//	 * To be called in the model at the start of its reduce method	 ¶//	 */¶//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {¶//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);¶//	}¶	¶	¶	/*¶	 * Additions since assignment was last given¶	 */¶	public static final String BARRIER_CREATED = "Barrier Created:";¶	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; ¶	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; ¶	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; ¶	¶	public static final String JOINER_CREATED = "Joiner Created:";¶	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; ¶	public static final String JOINER_WAIT_END = "Joiner Wait End:"; ¶	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; ¶	public static final String JOINER_RELEASE = "Joiner Release:"; 	¶	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; ¶	public static final String MAP = "Map:";¶//	public static final String REDUCE = "Reduce:";¶¶	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";¶	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	¶	¶	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {¶		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		¶	}¶	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	¶	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {¶		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		¶	}¶	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	/*¶	 * Call after changing finished threads in the joiner¶	 */¶	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {¶		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );¶	}¶	/*¶	 * To be printed by thread aThreadNumber¶	 */¶	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {¶		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);¶	}¶	¶	¶	/*¶	 * Call after adding reduced map to final map¶	 */¶	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {¶		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);¶	}¶	¶	//---------------------------A3 Traces--------------------------------------¶	/**¶	 * To be called in the server at the start of its method for registering a client¶	 */¶	protected void traceRegister(Object aClient) {¶		trace (REGISTER + aClient);¶	}¶	/**¶	 * To be called in the server runnable when it is assigned a  client¶	 */¶	protected void traceClientAssignment(Object aClient) {¶		trace(CLIENT_ASSIGNED + aClient);¶	}	¶	¶	/**¶	 * To be called in the server runnable before invoking the callback in the client.¶	 * To be also called in the client at the start of its callback to process sublist	 * ¶	 */¶	public void traceRemoteList (Object aSublist) {¶		trace (REMOTE_LIST + aSublist);¶	}¶	/**¶	 * To be called in the client before returning its result.¶	 * To be also called in server runnable after receiving the result from the client¶	 */¶	public void traceRemoteResult (Object aResult) {¶		trace (REMOTE_RESULT + aResult);¶	}¶	/**¶	 * Static method be called by the client main method¶	 */¶	public static void traceExit(Class aClass) {¶		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);¶	}¶	¶	/**¶	 * Slave runnables and client objects can define the following two methods¶	 */¶	public synchronized void synchronizedNotify() {¶		traceNotify();¶		this.notify();¶	}	¶	public synchronized void synchronizedWait() throws InterruptedException {¶		traceWait();		¶		this.wait();¶		¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package com;

import java.beans.PropertyChangeEvent;


public abstract class AMapReduceTracer {
	public static String INFO_PREFIX = "";
	public static String WAIT = "wait";
	public static String NOTIFY = "notify";
	public static String ENQUEUE = "enqueue:";
	public static String DEQUEUE = "dequeue:";
	public static String ADD = "add:";
	public static String REDUCE = "reduce:";
	public static String NEW_MAPPER = "new mapper:";
	public static String MODEL = "Model"; // value returned by toString() method of model
	public static String VIEW = "View"; // value returned by toString() method of view
	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller
	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer
	public static final String QUIT = "quit";
	public static final String EXIT = "exit";

	public static final String QUITTING = "Quitting";
	public static final String REGISTER = "Register:";
	public static final String CLIENT_ASSIGNED = "Client Assigned:";

	public static final String REMOTE_LIST = "Remote List:";
	public static final String REMOTE_RESULT = "Remote Result:";


	public static final String START_TOKEN = "Start";
	public static final int BUFFER_SIZE = 2;	


	// -----------------------------A1 Traces----------------------------------
	protected String toPrefix() {
		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";
	}
	protected void trace(String aSuffix) {
		System.out.println(toPrefix() + aSuffix);
	}
	/**
	 * To be called before scanning for input string
	 */
	protected void traceNumbersPrompt() {
		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");
	}
	/**
	 * To be called in the controller and runnable
	 */
	protected void traceQuit() {
		trace (QUITTING);
	}
	/**
	 * To be called in the view at start of call to propertyChange
	 */
	protected void tracePropertyChange(PropertyChangeEvent anEvent) {
		trace(anEvent.toString());
	}
	/*
	 * To be called in the map methods of the mappers before returning
	 */
	public void traceMap(Object anInput, Object aKeyValue) {
		trace (MAP  + anInput + ":" + aKeyValue);		
	}
	/*
	 * To be called in the reducer before returning
	 */
	protected void traceReduce(Object aList,  Object aReducedMap) {
		trace(REDUCE + aList + ":" +  aReducedMap);
	}
	/*
	 * 
	 */
	public static void traceMapperChange(Class aClass, Object aNewMapper) {
		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);
	}
	
	//----------------------------A2 traces -----------------------------------
	/**
	 * To be called before scanning for number of threads
	 */
	protected void traceThreadPrompt() {
		trace("Please enter the number of threads");
	}
	/**
	 * To be called before a wait on this
	 */
	protected void traceWait() {
		trace (WAIT);
	}
	/**
	 * To be called before doing a notify on this 
	 */
	protected void traceNotify() {
		trace(NOTIFY);
	}
//	/**
//	 * To be called by a summer slave thread before adding an int to its sublist 
//	 */
//	protected void traceAdd(int anInt) {
//		trace ( ADD + anInt);
//	}
	/**
	 * To be called by a master thread before adding an element to 
	 * a queue
	 */
	protected void traceEnqueueRequest(Object anElement) {
		trace(ENQUEUE + anElement);
	}
	/**
	 * To be called by a  master thread after adding an object to 
	 * a queue
	 */
	protected void traceEnqueue(Object aQueue) {
		trace(ENQUEUE + aQueue);
	}
	/**
	 * To be called by a slave thread before executing a take from
	 * queue 
	 */
	protected void traceDequeueRequest(Object aQueue) {
		trace (DEQUEUE + aQueue);
	}
	/**
	 * To be called by a slave thread after taking an object from a
	 * queue 
	 */
	protected void traceDequeue(Object anElement) {
		trace (DEQUEUE + anElement);
	}
	
//	/**
//	 * To be called in the model at the start of its reduce method	 
//	 */
//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {
//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);
//	}
	
	
	/*
	 * Additions since assignment was last given
	 */
	public static final String BARRIER_CREATED = "Barrier Created:";
	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; 
	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; 
	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; 
	
	public static final String JOINER_CREATED = "Joiner Created:";
	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; 
	public static final String JOINER_WAIT_END = "Joiner Wait End:"; 
	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; 
	public static final String JOINER_RELEASE = "Joiner Release:"; 	
	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; 
	public static final String MAP = "Map:";
//	public static final String REDUCE = "Reduce:";

	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";
	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	
	
	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {
		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		
	}
	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {
		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		
	}
	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {
		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		
	}
	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {
		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		
	}
	
	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {
		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		
	}
	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {
		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		
	}
	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {
		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		
	}
	/*
	 * Call after changing finished threads in the joiner
	 */
	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {
		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		
	}
	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {
		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		
	}
	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {
		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );
	}
	/*
	 * To be printed by thread aThreadNumber
	 */
	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {
		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);
	}
	
	
	/*
	 * Call after adding reduced map to final map
	 */
	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {
		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);
	}
	
	//---------------------------A3 Traces--------------------------------------
	/**
	 * To be called in the server at the start of its method for registering a client
	 */
	protected void traceRegister(Object aClient) {
		trace (REGISTER + aClient);
	}
	/**
	 * To be called in the server runnable when it is assigned a  client
	 */
	protected void traceClientAssignment(Object aClient) {
		trace(CLIENT_ASSIGNED + aClient);
	}	
	
	/**
	 * To be called in the server runnable before invoking the callback in the client.
	 * To be also called in the client at the start of its callback to process sublist	 * 
	 */
	public void traceRemoteList (Object aSublist) {
		trace (REMOTE_LIST + aSublist);
	}
	/**
	 * To be called in the client before returning its result.
	 * To be also called in server runnable after receiving the result from the client
	 */
	public void traceRemoteResult (Object aResult) {
		trace (REMOTE_RESULT + aResult);
	}
	/**
	 * Static method be called by the client main method
	 */
	public static void traceExit(Class aClass) {
		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);
	}
	
	/**
	 * Slave runnables and client objects can define the following two methods
	 */
	public synchronized void synchronizedNotify() {
		traceNotify();
		this.notify();
	}	
	public synchronized void synchronizedWait() throws InterruptedException {
		traceWait();		
		this.wait();
		
	}
}
]]></snapshot>
  </Command>
  <Command __id="189" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:49 EDT 2020" docASTNodeCount="1746" docActiveCodeLength="11924" docExpressionCount="1196" docLength="12652" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="334936">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\HalloweenServer.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;

import assignments.util.MiscAssignmentUtils;
import assignments.util.inputParameters.AnAbstractSimulationParametersBean;
import assignments.util.mainArgs.ServerArgsProcessor;
import consensus.ProposalFeedbackKind;
import inputport.nio.manager.NIOManager;
import inputport.nio.manager.NIOManagerFactory;
import inputport.nio.manager.factories.classes.AnAcceptCommandFactory;
import inputport.nio.manager.factories.selectors.AcceptCommandFactorySelector;
import inputport.rpc.ACachingAbstractRPCProxyInvocationHandler;
import inputport.rpc.GIPCLocateRegistry;
import inputport.rpc.GIPCRegistry;
import port.ATracingConnectionListener;
import util.interactiveMethodInvocation.ConsensusAlgorithm;
import util.interactiveMethodInvocation.IPCMechanism;
import util.interactiveMethodInvocation.SimulationParametersControllerFactory;
import util.trace.TooManyTracesException;
import util.trace.Tracer;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.PortTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.consensus.ProposalAcceptRequestSent;
import util.trace.port.consensus.ProposalAcceptedNotificationReceived;
import util.trace.port.consensus.ProposalLearnedNotificationSent;
import util.trace.port.consensus.RemoteProposeRequestReceived;
import util.trace.port.consensus.RemoteProposeRequestSent;
import util.trace.port.consensus.communication.CommunicationStateNames;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.nio.SocketChannelBound;
import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;
import util.trace.port.rpc.rmi.RMIObjectRegistered;
import util.trace.port.rpc.rmi.RMIRegistryLocated;
import util.trace.port.rpc.rmi.RMITraceUtility;


public class HalloweenServer extends AnAbstractSimulationParametersBean implements DistributedConsensusServer, NIOServer{
	protected int port;
	protected String host; 
	protected int GIPCPort;
	protected int serverPort;
	protected int NIOPort;
	protected int count = 0;
	protected List<DistributedConsensusClient> clientList = new ArrayList<>();
	protected List<String> nameList = new ArrayList<>();
//	private int GIPCCount = 0;
	private List<DistributedConsensusClient> GIPCClientList = new ArrayList<>();
	protected List<String> GIPCNameList = new ArrayList<>();
	private List<DistributedConsensusClient> currentClientList;
	private List<String> currentNameList;
//	private int currentCount = 0;
	
	protected List<SocketChannel> channels = new ArrayList<SocketChannel>();
	protected NIOManager nioManager = NIOManagerFactory.getSingleton();
	private final static int BUFFER_SIZE = 512;
	public static final String READ_THREAD_NAME = "Read Thread";

	private ArrayBlockingQueue<Message> bufferQueue = new ArrayBlockingQueue<>(BUFFER_SIZE);
	private Thread readThread;
	
	
	
	protected void setTracing() {
		PortTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		FactoryTraceUtility.setTracing();		
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		GIPCRPCTraceUtility.setTracing();
		trace(true);
	}
	
	@Override
	public void trace(boolean newValue) {
		super.trace(newValue);
		Tracer.showInfo(isTrace());
	}
	
	protected void setFactories() {
		AcceptCommandFactorySelector.setFactory(new AnAcceptCommandFactory(SelectionKey.OP_READ));
	}
	
	protected void init(String[] args) {
		port = ServerArgsProcessor.getRegistryPort(args);
		host = ServerArgsProcessor.getRegistryHost(args);
		GIPCPort = ServerArgsProcessor.getGIPCServerPort(args);
		serverPort = ServerArgsProcessor.getServerPort(args);
		NIOPort = ServerArgsProcessor.getNIOServerPort(args);
		setTracing();
		setFactories();
	}
	public void start(String args[]) {
		init(args);
		ACachingAbstractRPCProxyInvocationHandler.setInvokeObjectMethodsRemotely(false);
		try {
			Registry rmiRegistry = LocateRegistry.getRegistry(port);
			RMIRegistryLocated.newCase(this, host, port, rmiRegistry);
			RMIObjectRegistered.newCase(this, DistributedConsensusServer.class.getName(), this, rmiRegistry);
			UnicastRemoteObject.exportObject(this, 0);
			rmiRegistry.rebind(DistributedConsensusServer.class.getName(), this);
		} catch (Exception e) {
			e.printStackTrace();
		}

		GIPCRegistry gipcRegistry = GIPCLocateRegistry.createRegistry(GIPCPort);
		gipcRegistry.rebind("GIPCServer", this);
		gipcRegistry.getInputPort().addConnectionListener(new ATracingConnectionListener(gipcRegistry.getInputPort()));
//		ipcMechanism = IPCMechanism.NIO;
		currentClientList = clientList;
		currentNameList = nameList;
		
		try {
			ServerSocketChannel aServerFactoryChannel = ServerSocketChannel.open();
			InetSocketAddress anInternetSocketAddress = new InetSocketAddress(NIOPort);
			aServerFactoryChannel.socket().bind(anInternetSocketAddress);
			SocketChannelBound.newCase(this, aServerFactoryChannel, anInternetSocketAddress);
			nioManager.enableListenableAccepts(aServerFactoryChannel, this);
			
		} catch (IOException e) {
			e.printStackTrace();
		}		
		this.setBroadcastMetaState(true);
		readThread = new Thread(new ReadSlave(this));
		readThread.setName(READ_THREAD_NAME);
		readThread.start();
		SimulationParametersControllerFactory.getSingleton().addSimulationParameterListener(this);
		SimulationParametersControllerFactory.getSingleton().processCommands();		
	}

	@Override	
	public void quit(int aCode) {
		readThread.interrupt();
		System.exit(aCode);
	}
	
	@Override
	public void join(String clientName, DistributedConsensusClient client, IPCMechanism value) {
//		System.out.println("$$$$$$$$$$$$$$$$$$$$$$$: " + clientName);
//		for(StackTraceElement s:Thread.currentThread().getStackTrace())
//			System.out.println("$: " + s.getMethodName());
		switch(value) {
			case RMI:
				count++;
				clientList.add(client);
				nameList.add(clientName);
				return;
			case GIPC:
//				GIPCCount++;
				GIPCClientList.add(client);
				GIPCNameList.add(clientName);
			case NIO:
				return ;
		}
		
	}

	@Override
	public void broadcast(String clientName, String newCommand, IPCMechanism ipcMechanism) {
		changeIPC(ipcMechanism);
		
		int num = currentClientList.size();
			
		for(int i = 0; i < num; i++) {
			if(!(clientName.equals(currentNameList.get(i)) && !isAtomicBroadcast())) {
				ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
				try {
					currentClientList.get(i).updateCommand(newCommand);
				} catch(RemoteException e) {
					e.printStackTrace();
				}
			}
		}

	}
	
	@Override
	public void broadcast(String clientName, String newCommand, IPCMechanism value, ConsensusAlgorithm algorithm){
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
		if(algorithm == ConsensusAlgorithm.CENTRALIZED_ASYNCHRONOUS) {
			this.broadcast(clientName, newCommand, value);
		}
		else if(algorithm == ConsensusAlgorithm.CENTRALIZED_SYNCHRONOUS){
			
			int num = clientList.size();
			ProposalFeedbackKind feedback;
			for(int i = 0; i < num; i++) {
				ProposalAcceptRequestSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
				try {
					feedback = clientList.get(i).accept(CommunicationStateNames.COMMAND, newCommand);
					ProposalAcceptedNotificationReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand, feedback);
					if(feedback != ProposalFeedbackKind.SUCCESS) {
						newCommand = "";
						break;
					}
				} catch (RemoteException e) {
					e.printStackTrace();
				}
			}
			
			broadcast(clientName, newCommand, value);
//			ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
//			num = currentClientList.size();
//			for(int i = 0; i < num; i++) {
//				try {
//					currentClientList.get(i).updateCommand(newCommand);
//				} catch (RemoteException e) {
//					e.printStackTrace();
//				}	
//			}
			
		}
		
	}
	@Override
	public void ipcMechanism(IPCMechanism newValue) {
		super.ipcMechanism(newValue);
		changeIPC(newValue);
		if(isBroadcastMetaState())
		{
			try {
				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
//				server.broadcastIPCMetaState(clientName, newValue);
				for(int i = 0; i < count; i++) {
					clientList.get(i).setIPCMetaState(newValue);
				}
			} catch (RemoteException e) {
				e.printStackTrace();
			} catch (TooManyTracesException e) {
				e.printStackTrace();
			}
		}
	}
	
	public void atomicBroadcast(boolean newValue) {
		super.atomicBroadcast(newValue);
		if(isBroadcastMetaState())
		{
			try {
				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
//				server.broadcastIPCMetaState(clientName, newValue);
				for(int i = 0; i < count; i++) {
					clientList.get(i).setBroadcastMode(newValue);
				}
			} catch (RemoteException e) {
				e.printStackTrace();
			} catch (TooManyTracesException e) {
				e.printStackTrace();
			}
		}
		
	}
	@Override
	public void consensusAlgorithm(ConsensusAlgorithm newVal) {
		this.consensusAlgorithm = newVal;
		if(newVal == ConsensusAlgorithm.CENTRALIZED_SYNCHRONOUS) this.atomicBroadcast(true);
	}
	
	
	public void changeIPC(IPCMechanism newValue) {
		switch(newValue) {
			case RMI:
				currentNameList = nameList;
				currentClientList = clientList;
				return;
			case GIPC:
				currentNameList = GIPCNameList;
				currentClientList = GIPCClientList;
				return;
			case NIO:
				return ;
		}
	}
	
	@Override
	public void broadcastIPCMetaState(String clientName, IPCMechanism value) {
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, value);
		ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, value);
		setIPCMechanism(value);
		changeIPC(value);
		try {
			for(int i = 0; i < count; i++) {
				if(!(clientName.equals(nameList.get(i)))) {
					clientList.get(i).setIPCMetaState(value);
				}
			}
		} catch (RemoteException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void socketChannelAccepted(ServerSocketChannel aServerSocketChannel, SocketChannel aSocketChannel) {
		nioManager.addReadListener(aSocketChannel, this);
		channels.add(aSocketChannel);
	}
	@Override
	public void socketChannelRead(SocketChannel aSocketChannel, ByteBuffer aMessage, int aLength) {
		if(!bufferQueue.add(new Message(aSocketChannel, MiscAssignmentUtils.deepDuplicate(aMessage), aLength))) {
			System.out.println("Buffer is full!");
		}
	}
	@Override
	public void written(SocketChannel aSocketChannel, ByteBuffer aMessage, int aLength) {
		
	}

	@Override
	public void finishRead(Message message) {
		String newCommand = new String(message.getBuffer().array(), message.getBuffer().position(), message.getLength());
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
		for(SocketChannel ch : channels) {
			if(!(message.getChannel().equals(ch) && !isAtomicBroadcast())) {
				ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
				nioManager.write(ch, message.getBuffer(), this);
			}
		}	
	}

	@Override
	public ArrayBlockingQueue<Message> getBufferQueue() {
		return this.bufferQueue;
	}

	@Override
	public void broadcastBroadcastMode(String clientName, boolean value){
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, value);
		ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, value);
		super.setAtomicBroadcast(value);
		try {
			for(int i = 0; i < count; i++) {
				if(!clientName.equals(nameList.get(i))) {
					clientList.get(i).setBroadcastMode(value);
				}
			}
		} catch (RemoteException e) {
			e.printStackTrace();
		}
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="198" _type="Replace" date="Wed Jun 10 22:12:52 EDT 2020" docASTNodeCount="1746" docActiveCodeLength="11920" docExpressionCount="1196" docLength="12648" endLine="0" insertionLength="3" int_docASTNodeCount="1744" int_docActiveCodeLength="11917" int_docExpressionCount="1195" int_docLength="12645" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="337609">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="201" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:52 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="338390">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.beans.PropertyChangeEvent;¶¶¶public abstract class AMapReduceTracer {¶	public static String INFO_PREFIX = "";¶	public static String WAIT = "wait";¶	public static String NOTIFY = "notify";¶	public static String ENQUEUE = "enqueue:";¶	public static String DEQUEUE = "dequeue:";¶	public static String ADD = "add:";¶	public static String REDUCE = "reduce:";¶	public static String NEW_MAPPER = "new mapper:";¶	public static String MODEL = "Model"; // value returned by toString() method of model¶	public static String VIEW = "View"; // value returned by toString() method of view¶	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller¶	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer¶	public static final String QUIT = "quit";¶	public static final String EXIT = "exit";¶¶	public static final String QUITTING = "Quitting";¶	public static final String REGISTER = "Register:";¶	public static final String CLIENT_ASSIGNED = "Client Assigned:";¶¶	public static final String REMOTE_LIST = "Remote List:";¶	public static final String REMOTE_RESULT = "Remote Result:";¶¶¶	public static final String START_TOKEN = "Start";¶	public static final int BUFFER_SIZE = 2;	¶¶¶	// -----------------------------A1 Traces----------------------------------¶	protected String toPrefix() {¶		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";¶	}¶	protected void trace(String aSuffix) {¶		System.out.println(toPrefix() + aSuffix);¶	}¶	/**¶	 * To be called before scanning for input string¶	 */¶	protected void traceNumbersPrompt() {¶		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");¶	}¶	/**¶	 * To be called in the controller and runnable¶	 */¶	protected void traceQuit() {¶		trace (QUITTING);¶	}¶	/**¶	 * To be called in the view at start of call to propertyChange¶	 */¶	protected void tracePropertyChange(PropertyChangeEvent anEvent) {¶		trace(anEvent.toString());¶	}¶	/*¶	 * To be called in the map methods of the mappers before returning¶	 */¶	public void traceMap(Object anInput, Object aKeyValue) {¶		trace (MAP  + anInput + ":" + aKeyValue);		¶	}¶	/*¶	 * To be called in the reducer before returning¶	 */¶	protected void traceReduce(Object aList,  Object aReducedMap) {¶		trace(REDUCE + aList + ":" +  aReducedMap);¶	}¶	/*¶	 * ¶	 */¶	public static void traceMapperChange(Class aClass, Object aNewMapper) {¶		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);¶	}¶	¶	//----------------------------A2 traces -----------------------------------¶	/**¶	 * To be called before scanning for number of threads¶	 */¶	protected void traceThreadPrompt() {¶		trace("Please enter the number of threads");¶	}¶	/**¶	 * To be called before a wait on this¶	 */¶	protected void traceWait() {¶		trace (WAIT);¶	}¶	/**¶	 * To be called before doing a notify on this ¶	 */¶	protected void traceNotify() {¶		trace(NOTIFY);¶	}¶//	/**¶//	 * To be called by a summer slave thread before adding an int to its sublist ¶//	 */¶//	protected void traceAdd(int anInt) {¶//		trace ( ADD + anInt);¶//	}¶	/**¶	 * To be called by a master thread before adding an element to ¶	 * a queue¶	 */¶	protected void traceEnqueueRequest(Object anElement) {¶		trace(ENQUEUE + anElement);¶	}¶	/**¶	 * To be called by a  master thread after adding an object to ¶	 * a queue¶	 */¶	protected void traceEnqueue(Object aQueue) {¶		trace(ENQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread before executing a take from¶	 * queue ¶	 */¶	protected void traceDequeueRequest(Object aQueue) {¶		trace (DEQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread after taking an object from a¶	 * queue ¶	 */¶	protected void traceDequeue(Object anElement) {¶		trace (DEQUEUE + anElement);¶	}¶	¶//	/**¶//	 * To be called in the model at the start of its reduce method	 ¶//	 */¶//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {¶//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);¶//	}¶	¶	¶	/*¶	 * Additions since assignment was last given¶	 */¶	public static final String BARRIER_CREATED = "Barrier Created:";¶	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; ¶	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; ¶	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; ¶	¶	public static final String JOINER_CREATED = "Joiner Created:";¶	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; ¶	public static final String JOINER_WAIT_END = "Joiner Wait End:"; ¶	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; ¶	public static final String JOINER_RELEASE = "Joiner Release:"; 	¶	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; ¶	public static final String MAP = "Map:";¶//	public static final String REDUCE = "Reduce:";¶¶	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";¶	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	¶	¶	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {¶		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		¶	}¶	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	¶	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {¶		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		¶	}¶	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	/*¶	 * Call after changing finished threads in the joiner¶	 */¶	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {¶		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );¶	}¶	/*¶	 * To be printed by thread aThreadNumber¶	 */¶	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {¶		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);¶	}¶	¶	¶	/*¶	 * Call after adding reduced map to final map¶	 */¶	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {¶		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);¶	}¶	¶	//---------------------------A3 Traces--------------------------------------¶	/**¶	 * To be called in the server at the start of its method for registering a client¶	 */¶	protected void traceRegister(Object aClient) {¶		trace (REGISTER + aClient);¶	}¶	/**¶	 * To be called in the server runnable when it is assigned a  client¶	 */¶	protected void traceClientAssignment(Object aClient) {¶		trace(CLIENT_ASSIGNED + aClient);¶	}	¶	¶	/**¶	 * To be called in the server runnable before invoking the callback in the client.¶	 * To be also called in the client at the start of its callback to process sublist	 * ¶	 */¶	public void traceRemoteList (Object aSublist) {¶		trace (REMOTE_LIST + aSublist);¶	}¶	/**¶	 * To be called in the client before returning its result.¶	 * To be also called in server runnable after receiving the result from the client¶	 */¶	public void traceRemoteResult (Object aResult) {¶		trace (REMOTE_RESULT + aResult);¶	}¶	/**¶	 * Static method be called by the client main method¶	 */¶	public static void traceExit(Class aClass) {¶		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);¶	}¶	¶	/**¶	 * Slave runnables and client objects can define the following two methods¶	 */¶	public synchronized void synchronizedNotify() {¶		traceNotify();¶		this.notify();¶	}	¶	public synchronized void synchronizedWait() throws InterruptedException {¶		traceWait();		¶		this.wait();¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="205" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:53 EDT 2020" docASTNodeCount="137" docActiveCodeLength="747" docExpressionCount="71" docLength="747" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="339291">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\Message.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class Message {
	public SocketChannel channel;
	public ByteBuffer buffer;
	public int length;
	public Message(SocketChannel channel, ByteBuffer buffer,int length) {
		this.channel = channel;
		this.buffer = buffer;
		this.length = length;
	}
	public SocketChannel getChannel() {
		return channel;
	}
	public void setChannel(SocketChannel channel) {
		this.channel = channel;
	}
	public ByteBuffer getBuffer() {
		return buffer;
	}
	public void setBuffer(ByteBuffer buffer) {
		this.buffer = buffer;
	}
	public int getLength() {
		return length;
	}
	public void setLength(int length) {
		this.length = length;
	}
	
	
}
]]></snapshot>
  </Command>
  <Command __id="207" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:55 EDT 2020" docASTNodeCount="1746" docActiveCodeLength="11920" docExpressionCount="1196" docLength="12648" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="340848">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\HalloweenServer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com"), Diff(DELETE,"p533"), Diff(EQUAL,";¶import java.io.IOException;¶import java.net.InetSocketAddress;¶import java.nio.ByteBuffer;¶import java.nio.channels.SelectionKey;¶import java.nio.channels.ServerSocketChannel;¶import java.nio.channels.SocketChannel;¶import java.rmi.RemoteException;¶import java.rmi.registry.LocateRegistry;¶import java.rmi.registry.Registry;¶import java.rmi.server.UnicastRemoteObject;¶import java.util.ArrayList;¶import java.util.List;¶import java.util.concurrent.ArrayBlockingQueue;¶¶import assignments.util.MiscAssignmentUtils;¶import assignments.util.inputParameters.AnAbstractSimulationParametersBean;¶import assignments.util.mainArgs.ServerArgsProcessor;¶import consensus.ProposalFeedbackKind;¶import inputport.nio.manager.NIOManager;¶import inputport.nio.manager.NIOManagerFactory;¶import inputport.nio.manager.factories.classes.AnAcceptCommandFactory;¶import inputport.nio.manager.factories.selectors.AcceptCommandFactorySelector;¶import inputport.rpc.ACachingAbstractRPCProxyInvocationHandler;¶import inputport.rpc.GIPCLocateRegistry;¶import inputport.rpc.GIPCRegistry;¶import port.ATracingConnectionListener;¶import util.interactiveMethodInvocation.ConsensusAlgorithm;¶import util.interactiveMethodInvocation.IPCMechanism;¶import util.interactiveMethodInvocation.SimulationParametersControllerFactory;¶import util.trace.TooManyTracesException;¶import util.trace.Tracer;¶import util.trace.bean.BeanTraceUtility;¶import util.trace.factories.FactoryTraceUtility;¶import util.trace.misc.ThreadDelayed;¶import util.trace.port.PortTraceUtility;¶import util.trace.port.consensus.ConsensusTraceUtility;¶import util.trace.port.consensus.ProposalAcceptRequestSent;¶import util.trace.port.consensus.ProposalAcceptedNotificationReceived;¶import util.trace.port.consensus.ProposalLearnedNotificationSent;¶import util.trace.port.consensus.RemoteProposeRequestReceived;¶import util.trace.port.consensus.RemoteProposeRequestSent;¶import util.trace.port.consensus.communication.CommunicationStateNames;¶import util.trace.port.nio.NIOTraceUtility;¶import util.trace.port.nio.SocketChannelBound;¶import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;¶import util.trace.port.rpc.rmi.RMIObjectRegistered;¶import util.trace.port.rpc.rmi.RMIRegistryLocated;¶import util.trace.port.rpc.rmi.RMITraceUtility;¶¶¶public class HalloweenServer extends AnAbstractSimulationParametersBean implements DistributedConsensusServer, NIOServer{¶	protected int port;¶	protected String host; ¶	protected int GIPCPort;¶	protected int serverPort;¶	protected int NIOPort;¶	protected int count = 0;¶	protected List<DistributedConsensusClient> clientList = new ArrayList<>();¶	protected List<String> nameList = new ArrayList<>();¶//	private int GIPCCount = 0;¶	private List<DistributedConsensusClient> GIPCClientList = new ArrayList<>();¶	protected List<String> GIPCNameList = new ArrayList<>();¶	private List<DistributedConsensusClient> currentClientList;¶	private List<String> currentNameList;¶//	private int currentCount = 0;¶	¶	protected List<SocketChannel> channels = new ArrayList<SocketChannel>();¶	protected NIOManager nioManager = NIOManagerFactory.getSingleton();¶	private final static int BUFFER_SIZE = 512;¶	public static final String READ_THREAD_NAME = "Read Thread";¶¶	private ArrayBlockingQueue<Message> bufferQueue = new ArrayBlockingQueue<>(BUFFER_SIZE);¶	private Thread readThread;¶	¶	¶	¶	protected void setTracing() {¶		PortTraceUtility.setTracing();¶		NIOTraceUtility.setTracing();¶		RMITraceUtility.setTracing();¶		BeanTraceUtility.setTracing();¶		FactoryTraceUtility.setTracing();		¶		ConsensusTraceUtility.setTracing();¶		ThreadDelayed.enablePrint();¶		GIPCRPCTraceUtility.setTracing();¶		trace(true);¶	}¶	¶	@Override¶	public void trace(boolean newValue) {¶		super.trace(newValue);¶		Tracer.showInfo(isTrace());¶	}¶	¶	protected void setFactories() {¶		AcceptCommandFactorySelector.setFactory(new AnAcceptCommandFactory(SelectionKey.OP_READ));¶	}¶	¶	protected void init(String[] args) {¶		port = ServerArgsProcessor.getRegistryPort(args);¶		host = ServerArgsProcessor.getRegistryHost(args);¶		GIPCPort = ServerArgsProcessor.getGIPCServerPort(args);¶		serverPort = ServerArgsProcessor.getServerPort(args);¶		NIOPort = ServerArgsProcessor.getNIOServerPort(args);¶		setTracing();¶		setFactories();¶	}¶	public void start(String args[]) {¶		init(args);¶		ACachingAbstractRPCProxyInvocationHandler.setInvokeObjectMethodsRemotely(false);¶		try {¶			Registry rmiRegistry = LocateRegistry.getRegistry(port);¶			RMIRegistryLocated.newCase(this, host, port, rmiRegistry);¶			RMIObjectRegistered.newCase(this, DistributedConsensusServer.class.getName(), this, rmiRegistry);¶			UnicastRemoteObject.exportObject(this, 0);¶			rmiRegistry.rebind(DistributedConsensusServer.class.getName(), this);¶		} catch (Exception e) {¶			e.printStackTrace();¶		}¶¶		GIPCRegistry gipcRegistry = GIPCLocateRegistry.createRegistry(GIPCPort);¶		gipcRegistry.rebind("GIPCServer", this);¶		gipcRegistry.getInputPort().addConnectionListener(new ATracingConnectionListener(gipcRegistry.getInputPort()));¶//		ipcMechanism = IPCMechanism.NIO;¶		currentClientList = clientList;¶		currentNameList = nameList;¶		¶		try {¶			ServerSocketChannel aServerFactoryChannel = ServerSocketChannel.open();¶			InetSocketAddress anInternetSocketAddress = new InetSocketAddress(NIOPort);¶			aServerFactoryChannel.socket().bind(anInternetSocketAddress);¶			SocketChannelBound.newCase(this, aServerFactoryChannel, anInternetSocketAddress);¶			nioManager.enableListenableAccepts(aServerFactoryChannel, this);¶			¶		} catch (IOException e) {¶			e.printStackTrace();¶		}		¶		this.setBroadcastMetaState(true);¶		readThread = new Thread(new ReadSlave(this));¶		readThread.setName(READ_THREAD_NAME);¶		readThread.start();¶		SimulationParametersControllerFactory.getSingleton().addSimulationParameterListener(this);¶		SimulationParametersControllerFactory.getSingleton().processCommands();		¶	}¶¶	@Override	¶	public void quit(int aCode) {¶		readThread.interrupt();¶		System.exit(aCode);¶	}¶	¶	@Override¶	public void join(String clientName, DistributedConsensusClient client, IPCMechanism value) {¶//		System.out.println("$$$$$$$$$$$$$$$$$$$$$$$: " + clientName);¶//		for(StackTraceElement s:Thread.currentThread().getStackTrace())¶//			System.out.println("$: " + s.getMethodName());¶		switch(value) {¶			case RMI:¶				count++;¶				clientList.add(client);¶				nameList.add(clientName);¶				return;¶			case GIPC:¶//				GIPCCount++;¶				GIPCClientList.add(client);¶				GIPCNameList.add(clientName);¶			case NIO:¶				return ;¶		}¶		¶	}¶¶	@Override¶	public void broadcast(String clientName, String newCommand, IPCMechanism ipcMechanism) {¶		changeIPC(ipcMechanism);¶		¶		int num = currentClientList.size();¶			¶		for(int i = 0; i < num; i++) {¶			if(!(clientName.equals(currentNameList.get(i)) && !isAtomicBroadcast())) {¶				ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);¶				try {¶					currentClientList.get(i).updateCommand(newCommand);¶				} catch(RemoteException e) {¶					e.printStackTrace();¶				}¶			}¶		}¶¶	}¶	¶	@Override¶	public void broadcast(String clientName, String newCommand, IPCMechanism value, ConsensusAlgorithm algorithm){¶		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);¶		if(algorithm == ConsensusAlgorithm.CENTRALIZED_ASYNCHRONOUS) {¶			this.broadcast(clientName, newCommand, value);¶		}¶		else if(algorithm == ConsensusAlgorithm.CENTRALIZED_SYNCHRONOUS){¶			¶			int num = clientList.size();¶			ProposalFeedbackKind feedback;¶			for(int i = 0; i < num; i++) {¶				ProposalAcceptRequestSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);¶				try {¶					feedback = clientList.get(i).accept(CommunicationStateNames.COMMAND, newCommand);¶					ProposalAcceptedNotificationReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand, feedback);¶					if(feedback != ProposalFeedbackKind.SUCCESS) {¶						newCommand = "";¶						break;¶					}¶				} catch (RemoteException e) {¶					e.printStackTrace();¶				}¶			}¶			¶			broadcast(clientName, newCommand, value);¶//			ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);¶//			num = currentClientList.size();¶//			for(int i = 0; i < num; i++) {¶//				try {¶//					currentClientList.get(i).updateCommand(newCommand);¶//				} catch (RemoteException e) {¶//					e.printStackTrace();¶//				}	¶//			}¶			¶		}¶		¶	}¶	@Override¶	public void ipcMechanism(IPCMechanism newValue) {¶		super.ipcMechanism(newValue);¶		changeIPC(newValue);¶		if(isBroadcastMetaState())¶		{¶			try {¶				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);¶//				server.broadcastIPCMetaState(clientName, newValue);¶				for(int i = 0; i < count; i++) {¶					clientList.get(i).setIPCMetaState(newValue);¶				}¶			} catch (RemoteException e) {¶				e.printStackTrace();¶			} catch (TooManyTracesException e) {¶				e.printStackTrace();¶			}¶		}¶	}¶	¶	public void atomicBroadcast(boolean newValue) {¶		super.atomicBroadcast(newValue);¶		if(isBroadcastMetaState())¶		{¶			try {¶				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);¶//				server.broadcastIPCMetaState(clientName, newValue);¶				for(int i = 0; i < count; i++) {¶					clientList.get(i).setBroadcastMode(newValue);¶				}¶			} catch (RemoteException e) {¶				e.printStackTrace();¶			} catch (TooManyTracesException e) {¶				e.printStackTrace();¶			}¶		}¶		¶	}¶	@Override¶	public void consensusAlgorithm(ConsensusAlgorithm newVal) {¶		this.consensusAlgorithm = newVal;¶		if(newVal == ConsensusAlgorithm.CENTRALIZED_SYNCHRONOUS) this.atomicBroadcast(true);¶	}¶	¶	¶	public void changeIPC(IPCMechanism newValue) {¶		switch(newValue) {¶			case RMI:¶				currentNameList = nameList;¶				currentClientList = clientList;¶				return;¶			case GIPC:¶				currentNameList = GIPCNameList;¶				currentClientList = GIPCClientList;¶				return;¶			case NIO:¶				return ;¶		}¶	}¶	¶	@Override¶	public void broadcastIPCMetaState(String clientName, IPCMechanism value) {¶		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, value);¶		ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, value);¶		setIPCMechanism(value);¶		changeIPC(value);¶		try {¶			for(int i = 0; i < count; i++) {¶				if(!(clientName.equals(nameList.get(i)))) {¶					clientList.get(i).setIPCMetaState(value);¶				}¶			}¶		} catch (RemoteException e) {¶			e.printStackTrace();¶		}¶	}¶¶	@Override¶	public void socketChannelAccepted(ServerSocketChannel aServerSocketChannel, SocketChannel aSocketChannel) {¶		nioManager.addReadListener(aSocketChannel, this);¶		channels.add(aSocketChannel);¶	}¶	@Override¶	public void socketChannelRead(SocketChannel aSocketChannel, ByteBuffer aMessage, int aLength) {¶		if(!bufferQueue.add(new Message(aSocketChannel, MiscAssignmentUtils.deepDuplicate(aMessage), aLength))) {¶			System.out.println("Buffer is full!");¶		}¶	}¶	@Override¶	public void written(SocketChannel aSocketChannel, ByteBuffer aMessage, int aLength) {¶		¶	}¶¶	@Override¶	public void finishRead(Message message) {¶		String newCommand = new String(message.getBuffer().array(), message.getBuffer().position(), message.getLength());¶		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);¶		for(SocketChannel ch : channels) {¶			if(!(message.getChannel().equals(ch) && !isAtomicBroadcast())) {¶				ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);¶				nioManager.write(ch, message.getBuffer(), this);¶			}¶		}	¶	}¶¶	@Override¶	public ArrayBlockingQueue<Message> getBufferQueue() {¶		return this.bufferQueue;¶	}¶¶	@Override¶	public void broadcastBroadcastMode(String clientName, boolean value){¶		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, value);¶		ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, value);¶		super.setAtomicBroadcast(value);¶		try {¶			for(int i = 0; i < count; i++) {¶				if(!clientName.equals(nameList.get(i))) {¶					clientList.get(i).setBroadcastMode(value);¶				}¶			}¶		} catch (RemoteException e) {¶			e.printStackTrace();¶		}¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package com;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;

import assignments.util.MiscAssignmentUtils;
import assignments.util.inputParameters.AnAbstractSimulationParametersBean;
import assignments.util.mainArgs.ServerArgsProcessor;
import consensus.ProposalFeedbackKind;
import inputport.nio.manager.NIOManager;
import inputport.nio.manager.NIOManagerFactory;
import inputport.nio.manager.factories.classes.AnAcceptCommandFactory;
import inputport.nio.manager.factories.selectors.AcceptCommandFactorySelector;
import inputport.rpc.ACachingAbstractRPCProxyInvocationHandler;
import inputport.rpc.GIPCLocateRegistry;
import inputport.rpc.GIPCRegistry;
import port.ATracingConnectionListener;
import util.interactiveMethodInvocation.ConsensusAlgorithm;
import util.interactiveMethodInvocation.IPCMechanism;
import util.interactiveMethodInvocation.SimulationParametersControllerFactory;
import util.trace.TooManyTracesException;
import util.trace.Tracer;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.PortTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.consensus.ProposalAcceptRequestSent;
import util.trace.port.consensus.ProposalAcceptedNotificationReceived;
import util.trace.port.consensus.ProposalLearnedNotificationSent;
import util.trace.port.consensus.RemoteProposeRequestReceived;
import util.trace.port.consensus.RemoteProposeRequestSent;
import util.trace.port.consensus.communication.CommunicationStateNames;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.nio.SocketChannelBound;
import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;
import util.trace.port.rpc.rmi.RMIObjectRegistered;
import util.trace.port.rpc.rmi.RMIRegistryLocated;
import util.trace.port.rpc.rmi.RMITraceUtility;


public class HalloweenServer extends AnAbstractSimulationParametersBean implements DistributedConsensusServer, NIOServer{
	protected int port;
	protected String host; 
	protected int GIPCPort;
	protected int serverPort;
	protected int NIOPort;
	protected int count = 0;
	protected List<DistributedConsensusClient> clientList = new ArrayList<>();
	protected List<String> nameList = new ArrayList<>();
//	private int GIPCCount = 0;
	private List<DistributedConsensusClient> GIPCClientList = new ArrayList<>();
	protected List<String> GIPCNameList = new ArrayList<>();
	private List<DistributedConsensusClient> currentClientList;
	private List<String> currentNameList;
//	private int currentCount = 0;
	
	protected List<SocketChannel> channels = new ArrayList<SocketChannel>();
	protected NIOManager nioManager = NIOManagerFactory.getSingleton();
	private final static int BUFFER_SIZE = 512;
	public static final String READ_THREAD_NAME = "Read Thread";

	private ArrayBlockingQueue<Message> bufferQueue = new ArrayBlockingQueue<>(BUFFER_SIZE);
	private Thread readThread;
	
	
	
	protected void setTracing() {
		PortTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		FactoryTraceUtility.setTracing();		
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		GIPCRPCTraceUtility.setTracing();
		trace(true);
	}
	
	@Override
	public void trace(boolean newValue) {
		super.trace(newValue);
		Tracer.showInfo(isTrace());
	}
	
	protected void setFactories() {
		AcceptCommandFactorySelector.setFactory(new AnAcceptCommandFactory(SelectionKey.OP_READ));
	}
	
	protected void init(String[] args) {
		port = ServerArgsProcessor.getRegistryPort(args);
		host = ServerArgsProcessor.getRegistryHost(args);
		GIPCPort = ServerArgsProcessor.getGIPCServerPort(args);
		serverPort = ServerArgsProcessor.getServerPort(args);
		NIOPort = ServerArgsProcessor.getNIOServerPort(args);
		setTracing();
		setFactories();
	}
	public void start(String args[]) {
		init(args);
		ACachingAbstractRPCProxyInvocationHandler.setInvokeObjectMethodsRemotely(false);
		try {
			Registry rmiRegistry = LocateRegistry.getRegistry(port);
			RMIRegistryLocated.newCase(this, host, port, rmiRegistry);
			RMIObjectRegistered.newCase(this, DistributedConsensusServer.class.getName(), this, rmiRegistry);
			UnicastRemoteObject.exportObject(this, 0);
			rmiRegistry.rebind(DistributedConsensusServer.class.getName(), this);
		} catch (Exception e) {
			e.printStackTrace();
		}

		GIPCRegistry gipcRegistry = GIPCLocateRegistry.createRegistry(GIPCPort);
		gipcRegistry.rebind("GIPCServer", this);
		gipcRegistry.getInputPort().addConnectionListener(new ATracingConnectionListener(gipcRegistry.getInputPort()));
//		ipcMechanism = IPCMechanism.NIO;
		currentClientList = clientList;
		currentNameList = nameList;
		
		try {
			ServerSocketChannel aServerFactoryChannel = ServerSocketChannel.open();
			InetSocketAddress anInternetSocketAddress = new InetSocketAddress(NIOPort);
			aServerFactoryChannel.socket().bind(anInternetSocketAddress);
			SocketChannelBound.newCase(this, aServerFactoryChannel, anInternetSocketAddress);
			nioManager.enableListenableAccepts(aServerFactoryChannel, this);
			
		} catch (IOException e) {
			e.printStackTrace();
		}		
		this.setBroadcastMetaState(true);
		readThread = new Thread(new ReadSlave(this));
		readThread.setName(READ_THREAD_NAME);
		readThread.start();
		SimulationParametersControllerFactory.getSingleton().addSimulationParameterListener(this);
		SimulationParametersControllerFactory.getSingleton().processCommands();		
	}

	@Override	
	public void quit(int aCode) {
		readThread.interrupt();
		System.exit(aCode);
	}
	
	@Override
	public void join(String clientName, DistributedConsensusClient client, IPCMechanism value) {
//		System.out.println("$$$$$$$$$$$$$$$$$$$$$$$: " + clientName);
//		for(StackTraceElement s:Thread.currentThread().getStackTrace())
//			System.out.println("$: " + s.getMethodName());
		switch(value) {
			case RMI:
				count++;
				clientList.add(client);
				nameList.add(clientName);
				return;
			case GIPC:
//				GIPCCount++;
				GIPCClientList.add(client);
				GIPCNameList.add(clientName);
			case NIO:
				return ;
		}
		
	}

	@Override
	public void broadcast(String clientName, String newCommand, IPCMechanism ipcMechanism) {
		changeIPC(ipcMechanism);
		
		int num = currentClientList.size();
			
		for(int i = 0; i < num; i++) {
			if(!(clientName.equals(currentNameList.get(i)) && !isAtomicBroadcast())) {
				ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
				try {
					currentClientList.get(i).updateCommand(newCommand);
				} catch(RemoteException e) {
					e.printStackTrace();
				}
			}
		}

	}
	
	@Override
	public void broadcast(String clientName, String newCommand, IPCMechanism value, ConsensusAlgorithm algorithm){
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
		if(algorithm == ConsensusAlgorithm.CENTRALIZED_ASYNCHRONOUS) {
			this.broadcast(clientName, newCommand, value);
		}
		else if(algorithm == ConsensusAlgorithm.CENTRALIZED_SYNCHRONOUS){
			
			int num = clientList.size();
			ProposalFeedbackKind feedback;
			for(int i = 0; i < num; i++) {
				ProposalAcceptRequestSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
				try {
					feedback = clientList.get(i).accept(CommunicationStateNames.COMMAND, newCommand);
					ProposalAcceptedNotificationReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand, feedback);
					if(feedback != ProposalFeedbackKind.SUCCESS) {
						newCommand = "";
						break;
					}
				} catch (RemoteException e) {
					e.printStackTrace();
				}
			}
			
			broadcast(clientName, newCommand, value);
//			ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
//			num = currentClientList.size();
//			for(int i = 0; i < num; i++) {
//				try {
//					currentClientList.get(i).updateCommand(newCommand);
//				} catch (RemoteException e) {
//					e.printStackTrace();
//				}	
//			}
			
		}
		
	}
	@Override
	public void ipcMechanism(IPCMechanism newValue) {
		super.ipcMechanism(newValue);
		changeIPC(newValue);
		if(isBroadcastMetaState())
		{
			try {
				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
//				server.broadcastIPCMetaState(clientName, newValue);
				for(int i = 0; i < count; i++) {
					clientList.get(i).setIPCMetaState(newValue);
				}
			} catch (RemoteException e) {
				e.printStackTrace();
			} catch (TooManyTracesException e) {
				e.printStackTrace();
			}
		}
	}
	
	public void atomicBroadcast(boolean newValue) {
		super.atomicBroadcast(newValue);
		if(isBroadcastMetaState())
		{
			try {
				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
//				server.broadcastIPCMetaState(clientName, newValue);
				for(int i = 0; i < count; i++) {
					clientList.get(i).setBroadcastMode(newValue);
				}
			} catch (RemoteException e) {
				e.printStackTrace();
			} catch (TooManyTracesException e) {
				e.printStackTrace();
			}
		}
		
	}
	@Override
	public void consensusAlgorithm(ConsensusAlgorithm newVal) {
		this.consensusAlgorithm = newVal;
		if(newVal == ConsensusAlgorithm.CENTRALIZED_SYNCHRONOUS) this.atomicBroadcast(true);
	}
	
	
	public void changeIPC(IPCMechanism newValue) {
		switch(newValue) {
			case RMI:
				currentNameList = nameList;
				currentClientList = clientList;
				return;
			case GIPC:
				currentNameList = GIPCNameList;
				currentClientList = GIPCClientList;
				return;
			case NIO:
				return ;
		}
	}
	
	@Override
	public void broadcastIPCMetaState(String clientName, IPCMechanism value) {
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, value);
		ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, value);
		setIPCMechanism(value);
		changeIPC(value);
		try {
			for(int i = 0; i < count; i++) {
				if(!(clientName.equals(nameList.get(i)))) {
					clientList.get(i).setIPCMetaState(value);
				}
			}
		} catch (RemoteException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void socketChannelAccepted(ServerSocketChannel aServerSocketChannel, SocketChannel aSocketChannel) {
		nioManager.addReadListener(aSocketChannel, this);
		channels.add(aSocketChannel);
	}
	@Override
	public void socketChannelRead(SocketChannel aSocketChannel, ByteBuffer aMessage, int aLength) {
		if(!bufferQueue.add(new Message(aSocketChannel, MiscAssignmentUtils.deepDuplicate(aMessage), aLength))) {
			System.out.println("Buffer is full!");
		}
	}
	@Override
	public void written(SocketChannel aSocketChannel, ByteBuffer aMessage, int aLength) {
		
	}

	@Override
	public void finishRead(Message message) {
		String newCommand = new String(message.getBuffer().array(), message.getBuffer().position(), message.getLength());
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
		for(SocketChannel ch : channels) {
			if(!(message.getChannel().equals(ch) && !isAtomicBroadcast())) {
				ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
				nioManager.write(ch, message.getBuffer(), this);
			}
		}	
	}

	@Override
	public ArrayBlockingQueue<Message> getBufferQueue() {
		return this.bufferQueue;
	}

	@Override
	public void broadcastBroadcastMode(String clientName, boolean value){
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, value);
		ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, value);
		super.setAtomicBroadcast(value);
		try {
			for(int i = 0; i < count; i++) {
				if(!clientName.equals(nameList.get(i))) {
					clientList.get(i).setBroadcastMode(value);
				}
			}
		} catch (RemoteException e) {
			e.printStackTrace();
		}
	}
}
]]></snapshot>
  </Command>
  <Command __id="191" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:12:50 EDT 2020" starttimestamp="1591841234468" timestamp="336182" />
  <Command __id="192" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:12:50 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="336497" />
  <Command __id="193" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:12:51 EDT 2020" starttimestamp="1591841234468" timestamp="336532" />
  <Command __id="194" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:12:51 EDT 2020" starttimestamp="1591841234468" timestamp="336575" />
  <Command __id="195" _type="ShellCommand" date="Wed Jun 10 22:12:51 EDT 2020" starttimestamp="1591841234468" timestamp="337414" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="196" _type="ShellCommand" date="Wed Jun 10 22:12:52 EDT 2020" starttimestamp="1591841234468" timestamp="337559" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="197" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:12:52 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="337596" />
  <Command __id="199" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:12:52 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="337662" />
  <Command __id="200" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:12:52 EDT 2020" starttimestamp="1591841234468" timestamp="337827" />
  <Command __id="202" _type="MoveCaretCommand" caretOffset="284" date="Wed Jun 10 22:12:53 EDT 2020" docOffset="284" starttimestamp="1591841234468" timestamp="338657" />
  <Command __id="203" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:12:53 EDT 2020" starttimestamp="1591841234468" timestamp="338743" />
  <Command __id="204" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:12:53 EDT 2020" starttimestamp="1591841234468" timestamp="338937" />
  <Command __id="206" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:12:54 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="339950" />
  <Command __id="208" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:12:55 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="341041" />
  <Command __id="210" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:12:56 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="342316" />
  <Command __id="212" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:12:57 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="342820" />
  <Command __id="209" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:56 EDT 2020" docASTNodeCount="137" docActiveCodeLength="747" docExpressionCount="71" docLength="747" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="342065">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\Message.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package comp533;¶¶import java.nio.ByteBuffer;¶import java.nio.channels.SocketChannel;¶¶public class Message {¶	public SocketChannel channel;¶	public ByteBuffer buffer;¶	public int length;¶	public Message(SocketChannel channel, ByteBuffer buffer,int length) {¶		this.channel = channel;¶		this.buffer = buffer;¶		this.length = length;¶	}¶	public SocketChannel getChannel() {¶		return channel;¶	}¶	public void setChannel(SocketChannel channel) {¶		this.channel = channel;¶	}¶	public ByteBuffer getBuffer() {¶		return buffer;¶	}¶	public void setBuffer(ByteBuffer buffer) {¶		this.buffer = buffer;¶	}¶	public int getLength() {¶		return length;¶	}¶	public void setLength(int length) {¶		this.length = length;¶	}¶	¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="211" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:12:57 EDT 2020" docASTNodeCount="137" docActiveCodeLength="747" docExpressionCount="71" docLength="747" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="342742">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\Message.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package comp533;¶¶import java.nio.ByteBuffer;¶import java.nio.channels.SocketChannel;¶¶public class Message {¶	public SocketChannel channel;¶	public ByteBuffer buffer;¶	public int length;¶	public Message(SocketChannel channel, ByteBuffer buffer,int length) {¶		this.channel = channel;¶		this.buffer = buffer;¶		this.length = length;¶	}¶	public SocketChannel getChannel() {¶		return channel;¶	}¶	public void setChannel(SocketChannel channel) {¶		this.channel = channel;¶	}¶	public ByteBuffer getBuffer() {¶		return buffer;¶	}¶	public void setBuffer(ByteBuffer buffer) {¶		this.buffer = buffer;¶	}¶	public int getLength() {¶		return length;¶	}¶	public void setLength(int length) {¶		this.length = length;¶	}¶	¶	¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="223" _type="Replace" date="Wed Jun 10 22:12:59 EDT 2020" docASTNodeCount="137" docActiveCodeLength="743" docExpressionCount="71" docLength="743" endLine="0" insertionLength="3" int_docASTNodeCount="135" int_docActiveCodeLength="740" int_docExpressionCount="70" int_docLength="740" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="345319">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="213" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:12:58 EDT 2020" starttimestamp="1591841234468" timestamp="343912" />
  <Command __id="214" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:12:58 EDT 2020" starttimestamp="1591841234468" timestamp="344221" />
  <Command __id="215" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:12:58 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="344403" />
  <Command __id="216" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:12:58 EDT 2020" starttimestamp="1591841234468" timestamp="344452" />
  <Command __id="217" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:12:59 EDT 2020" starttimestamp="1591841234468" timestamp="344575" />
  <Command __id="218" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:12:59 EDT 2020" starttimestamp="1591841234468" timestamp="344712" />
  <Command __id="219" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:12:59 EDT 2020" starttimestamp="1591841234468" timestamp="344885" />
  <Command __id="220" _type="ShellCommand" date="Wed Jun 10 22:12:59 EDT 2020" starttimestamp="1591841234468" timestamp="345124" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="221" _type="ShellCommand" date="Wed Jun 10 22:12:59 EDT 2020" starttimestamp="1591841234468" timestamp="345285" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="222" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:12:59 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="345315" />
  <Command __id="224" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:12:59 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="345361" />
  <Command __id="225" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:12:59 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="345362" />
  <Command __id="226" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:13:00 EDT 2020" starttimestamp="1591841234468" timestamp="345670" />
  <Command __id="227" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:00 EDT 2020" starttimestamp="1591841234468" timestamp="346428" />
  <Command __id="228" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:00 EDT 2020" starttimestamp="1591841234468" timestamp="346523" />
  <Command __id="230" _type="MoveCaretCommand" caretOffset="284" date="Wed Jun 10 22:13:02 EDT 2020" docOffset="284" starttimestamp="1591841234468" timestamp="348096" />
  <Command __id="232" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:13:03 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="349240" />
  <Command __id="233" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:04 EDT 2020" starttimestamp="1591841234468" timestamp="350472" />
  <Command __id="234" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:13:05 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="350775" />
  <Command __id="235" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:05 EDT 2020" starttimestamp="1591841234468" timestamp="350812" />
  <Command __id="236" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:05 EDT 2020" starttimestamp="1591841234468" timestamp="350963" />
  <Command __id="237" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:05 EDT 2020" starttimestamp="1591841234468" timestamp="351179" />
  <Command __id="238" _type="ShellCommand" date="Wed Jun 10 22:13:06 EDT 2020" starttimestamp="1591841234468" timestamp="351662" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="239" _type="ShellCommand" date="Wed Jun 10 22:13:06 EDT 2020" starttimestamp="1591841234468" timestamp="351851" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="240" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:13:06 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="351874" />
  <Command __id="242" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:13:06 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="351917" />
  <Command __id="243" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:13:06 EDT 2020" starttimestamp="1591841234468" timestamp="352314" />
  <Command __id="244" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:07 EDT 2020" starttimestamp="1591841234468" timestamp="352984" />
  <Command __id="246" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:07 EDT 2020" starttimestamp="1591841234468" timestamp="353052" />
  <Command __id="247" _type="MoveCaretCommand" caretOffset="284" date="Wed Jun 10 22:13:07 EDT 2020" docOffset="284" starttimestamp="1591841234468" timestamp="353214" />
  <Command __id="249" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:13:08 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="354266" />
  <Command __id="229" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:02 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="347879">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.beans.PropertyChangeEvent;¶¶¶public abstract class AMapReduceTracer {¶	public static String INFO_PREFIX = "";¶	public static String WAIT = "wait";¶	public static String NOTIFY = "notify";¶	public static String ENQUEUE = "enqueue:";¶	public static String DEQUEUE = "dequeue:";¶	public static String ADD = "add:";¶	public static String REDUCE = "reduce:";¶	public static String NEW_MAPPER = "new mapper:";¶	public static String MODEL = "Model"; // value returned by toString() method of model¶	public static String VIEW = "View"; // value returned by toString() method of view¶	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller¶	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer¶	public static final String QUIT = "quit";¶	public static final String EXIT = "exit";¶¶	public static final String QUITTING = "Quitting";¶	public static final String REGISTER = "Register:";¶	public static final String CLIENT_ASSIGNED = "Client Assigned:";¶¶	public static final String REMOTE_LIST = "Remote List:";¶	public static final String REMOTE_RESULT = "Remote Result:";¶¶¶	public static final String START_TOKEN = "Start";¶	public static final int BUFFER_SIZE = 2;	¶¶¶	// -----------------------------A1 Traces----------------------------------¶	protected String toPrefix() {¶		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";¶	}¶	protected void trace(String aSuffix) {¶		System.out.println(toPrefix() + aSuffix);¶	}¶	/**¶	 * To be called before scanning for input string¶	 */¶	protected void traceNumbersPrompt() {¶		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");¶	}¶	/**¶	 * To be called in the controller and runnable¶	 */¶	protected void traceQuit() {¶		trace (QUITTING);¶	}¶	/**¶	 * To be called in the view at start of call to propertyChange¶	 */¶	protected void tracePropertyChange(PropertyChangeEvent anEvent) {¶		trace(anEvent.toString());¶	}¶	/*¶	 * To be called in the map methods of the mappers before returning¶	 */¶	public void traceMap(Object anInput, Object aKeyValue) {¶		trace (MAP  + anInput + ":" + aKeyValue);		¶	}¶	/*¶	 * To be called in the reducer before returning¶	 */¶	protected void traceReduce(Object aList,  Object aReducedMap) {¶		trace(REDUCE + aList + ":" +  aReducedMap);¶	}¶	/*¶	 * ¶	 */¶	public static void traceMapperChange(Class aClass, Object aNewMapper) {¶		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);¶	}¶	¶	//----------------------------A2 traces -----------------------------------¶	/**¶	 * To be called before scanning for number of threads¶	 */¶	protected void traceThreadPrompt() {¶		trace("Please enter the number of threads");¶	}¶	/**¶	 * To be called before a wait on this¶	 */¶	protected void traceWait() {¶		trace (WAIT);¶	}¶	/**¶	 * To be called before doing a notify on this ¶	 */¶	protected void traceNotify() {¶		trace(NOTIFY);¶	}¶//	/**¶//	 * To be called by a summer slave thread before adding an int to its sublist ¶//	 */¶//	protected void traceAdd(int anInt) {¶//		trace ( ADD + anInt);¶//	}¶	/**¶	 * To be called by a master thread before adding an element to ¶	 * a queue¶	 */¶	protected void traceEnqueueRequest(Object anElement) {¶		trace(ENQUEUE + anElement);¶	}¶	/**¶	 * To be called by a  master thread after adding an object to ¶	 * a queue¶	 */¶	protected void traceEnqueue(Object aQueue) {¶		trace(ENQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread before executing a take from¶	 * queue ¶	 */¶	protected void traceDequeueRequest(Object aQueue) {¶		trace (DEQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread after taking an object from a¶	 * queue ¶	 */¶	protected void traceDequeue(Object anElement) {¶		trace (DEQUEUE + anElement);¶	}¶	¶//	/**¶//	 * To be called in the model at the start of its reduce method	 ¶//	 */¶//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {¶//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);¶//	}¶	¶	¶	/*¶	 * Additions since assignment was last given¶	 */¶	public static final String BARRIER_CREATED = "Barrier Created:";¶	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; ¶	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; ¶	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; ¶	¶	public static final String JOINER_CREATED = "Joiner Created:";¶	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; ¶	public static final String JOINER_WAIT_END = "Joiner Wait End:"; ¶	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; ¶	public static final String JOINER_RELEASE = "Joiner Release:"; 	¶	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; ¶	public static final String MAP = "Map:";¶//	public static final String REDUCE = "Reduce:";¶¶	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";¶	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	¶	¶	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {¶		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		¶	}¶	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	¶	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {¶		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		¶	}¶	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	/*¶	 * Call after changing finished threads in the joiner¶	 */¶	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {¶		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );¶	}¶	/*¶	 * To be printed by thread aThreadNumber¶	 */¶	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {¶		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);¶	}¶	¶	¶	/*¶	 * Call after adding reduced map to final map¶	 */¶	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {¶		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);¶	}¶	¶	//---------------------------A3 Traces--------------------------------------¶	/**¶	 * To be called in the server at the start of its method for registering a client¶	 */¶	protected void traceRegister(Object aClient) {¶		trace (REGISTER + aClient);¶	}¶	/**¶	 * To be called in the server runnable when it is assigned a  client¶	 */¶	protected void traceClientAssignment(Object aClient) {¶		trace(CLIENT_ASSIGNED + aClient);¶	}	¶	¶	/**¶	 * To be called in the server runnable before invoking the callback in the client.¶	 * To be also called in the client at the start of its callback to process sublist	 * ¶	 */¶	public void traceRemoteList (Object aSublist) {¶		trace (REMOTE_LIST + aSublist);¶	}¶	/**¶	 * To be called in the client before returning its result.¶	 * To be also called in server runnable after receiving the result from the client¶	 */¶	public void traceRemoteResult (Object aResult) {¶		trace (REMOTE_RESULT + aResult);¶	}¶	/**¶	 * Static method be called by the client main method¶	 */¶	public static void traceExit(Class aClass) {¶		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);¶	}¶	¶	/**¶	 * Slave runnables and client objects can define the following two methods¶	 */¶	public synchronized void synchronizedNotify() {¶		traceNotify();¶		this.notify();¶	}	¶	public synchronized void synchronizedWait() throws InterruptedException {¶		traceWait();		¶		this.wait();¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="231" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:03 EDT 2020" docASTNodeCount="44" docActiveCodeLength="365" docExpressionCount="33" docLength="365" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="349085">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\NIOClient.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import inputport.nio.manager.listeners.SocketChannelConnectListener;
import inputport.nio.manager.listeners.SocketChannelReadListener;
import inputport.nio.manager.listeners.SocketChannelWriteListener;

public interface NIOClient extends SocketChannelConnectListener, SocketChannelWriteListener, SocketChannelReadListener, ReadMaster{

}
]]></snapshot>
  </Command>
  <DocumentChange __id="241" _type="Replace" date="Wed Jun 10 22:13:06 EDT 2020" docASTNodeCount="44" docActiveCodeLength="361" docExpressionCount="33" docLength="361" endLine="0" insertionLength="3" int_docASTNodeCount="42" int_docActiveCodeLength="358" int_docExpressionCount="32" int_docLength="358" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="351877">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="245" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:07 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="353010">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.beans.PropertyChangeEvent;¶¶¶public abstract class AMapReduceTracer {¶	public static String INFO_PREFIX = "";¶	public static String WAIT = "wait";¶	public static String NOTIFY = "notify";¶	public static String ENQUEUE = "enqueue:";¶	public static String DEQUEUE = "dequeue:";¶	public static String ADD = "add:";¶	public static String REDUCE = "reduce:";¶	public static String NEW_MAPPER = "new mapper:";¶	public static String MODEL = "Model"; // value returned by toString() method of model¶	public static String VIEW = "View"; // value returned by toString() method of view¶	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller¶	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer¶	public static final String QUIT = "quit";¶	public static final String EXIT = "exit";¶¶	public static final String QUITTING = "Quitting";¶	public static final String REGISTER = "Register:";¶	public static final String CLIENT_ASSIGNED = "Client Assigned:";¶¶	public static final String REMOTE_LIST = "Remote List:";¶	public static final String REMOTE_RESULT = "Remote Result:";¶¶¶	public static final String START_TOKEN = "Start";¶	public static final int BUFFER_SIZE = 2;	¶¶¶	// -----------------------------A1 Traces----------------------------------¶	protected String toPrefix() {¶		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";¶	}¶	protected void trace(String aSuffix) {¶		System.out.println(toPrefix() + aSuffix);¶	}¶	/**¶	 * To be called before scanning for input string¶	 */¶	protected void traceNumbersPrompt() {¶		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");¶	}¶	/**¶	 * To be called in the controller and runnable¶	 */¶	protected void traceQuit() {¶		trace (QUITTING);¶	}¶	/**¶	 * To be called in the view at start of call to propertyChange¶	 */¶	protected void tracePropertyChange(PropertyChangeEvent anEvent) {¶		trace(anEvent.toString());¶	}¶	/*¶	 * To be called in the map methods of the mappers before returning¶	 */¶	public void traceMap(Object anInput, Object aKeyValue) {¶		trace (MAP  + anInput + ":" + aKeyValue);		¶	}¶	/*¶	 * To be called in the reducer before returning¶	 */¶	protected void traceReduce(Object aList,  Object aReducedMap) {¶		trace(REDUCE + aList + ":" +  aReducedMap);¶	}¶	/*¶	 * ¶	 */¶	public static void traceMapperChange(Class aClass, Object aNewMapper) {¶		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);¶	}¶	¶	//----------------------------A2 traces -----------------------------------¶	/**¶	 * To be called before scanning for number of threads¶	 */¶	protected void traceThreadPrompt() {¶		trace("Please enter the number of threads");¶	}¶	/**¶	 * To be called before a wait on this¶	 */¶	protected void traceWait() {¶		trace (WAIT);¶	}¶	/**¶	 * To be called before doing a notify on this ¶	 */¶	protected void traceNotify() {¶		trace(NOTIFY);¶	}¶//	/**¶//	 * To be called by a summer slave thread before adding an int to its sublist ¶//	 */¶//	protected void traceAdd(int anInt) {¶//		trace ( ADD + anInt);¶//	}¶	/**¶	 * To be called by a master thread before adding an element to ¶	 * a queue¶	 */¶	protected void traceEnqueueRequest(Object anElement) {¶		trace(ENQUEUE + anElement);¶	}¶	/**¶	 * To be called by a  master thread after adding an object to ¶	 * a queue¶	 */¶	protected void traceEnqueue(Object aQueue) {¶		trace(ENQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread before executing a take from¶	 * queue ¶	 */¶	protected void traceDequeueRequest(Object aQueue) {¶		trace (DEQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread after taking an object from a¶	 * queue ¶	 */¶	protected void traceDequeue(Object anElement) {¶		trace (DEQUEUE + anElement);¶	}¶	¶//	/**¶//	 * To be called in the model at the start of its reduce method	 ¶//	 */¶//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {¶//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);¶//	}¶	¶	¶	/*¶	 * Additions since assignment was last given¶	 */¶	public static final String BARRIER_CREATED = "Barrier Created:";¶	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; ¶	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; ¶	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; ¶	¶	public static final String JOINER_CREATED = "Joiner Created:";¶	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; ¶	public static final String JOINER_WAIT_END = "Joiner Wait End:"; ¶	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; ¶	public static final String JOINER_RELEASE = "Joiner Release:"; 	¶	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; ¶	public static final String MAP = "Map:";¶//	public static final String REDUCE = "Reduce:";¶¶	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";¶	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	¶	¶	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {¶		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		¶	}¶	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	¶	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {¶		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		¶	}¶	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	/*¶	 * Call after changing finished threads in the joiner¶	 */¶	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {¶		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );¶	}¶	/*¶	 * To be printed by thread aThreadNumber¶	 */¶	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {¶		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);¶	}¶	¶	¶	/*¶	 * Call after adding reduced map to final map¶	 */¶	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {¶		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);¶	}¶	¶	//---------------------------A3 Traces--------------------------------------¶	/**¶	 * To be called in the server at the start of its method for registering a client¶	 */¶	protected void traceRegister(Object aClient) {¶		trace (REGISTER + aClient);¶	}¶	/**¶	 * To be called in the server runnable when it is assigned a  client¶	 */¶	protected void traceClientAssignment(Object aClient) {¶		trace(CLIENT_ASSIGNED + aClient);¶	}	¶	¶	/**¶	 * To be called in the server runnable before invoking the callback in the client.¶	 * To be also called in the client at the start of its callback to process sublist	 * ¶	 */¶	public void traceRemoteList (Object aSublist) {¶		trace (REMOTE_LIST + aSublist);¶	}¶	/**¶	 * To be called in the client before returning its result.¶	 * To be also called in server runnable after receiving the result from the client¶	 */¶	public void traceRemoteResult (Object aResult) {¶		trace (REMOTE_RESULT + aResult);¶	}¶	/**¶	 * Static method be called by the client main method¶	 */¶	public static void traceExit(Class aClass) {¶		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);¶	}¶	¶	/**¶	 * Slave runnables and client objects can define the following two methods¶	 */¶	public synchronized void synchronizedNotify() {¶		traceNotify();¶		this.notify();¶	}	¶	public synchronized void synchronizedWait() throws InterruptedException {¶		traceWait();		¶		this.wait();¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="248" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:08 EDT 2020" docASTNodeCount="44" docActiveCodeLength="363" docExpressionCount="33" docLength="363" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="354117">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\NIOServer.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import inputport.nio.manager.listeners.SocketChannelAcceptListener;
import inputport.nio.manager.listeners.SocketChannelReadListener;
import inputport.nio.manager.listeners.SocketChannelWriteListener;

public interface NIOServer extends SocketChannelAcceptListener, SocketChannelReadListener, SocketChannelWriteListener, ReadMaster{

}
]]></snapshot>
  </Command>
  <DocumentChange __id="257" _type="Replace" date="Wed Jun 10 22:13:11 EDT 2020" docASTNodeCount="44" docActiveCodeLength="359" docExpressionCount="33" docLength="359" endLine="0" insertionLength="3" int_docASTNodeCount="42" int_docActiveCodeLength="356" int_docExpressionCount="32" int_docLength="356" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="356887">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="260" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:11 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="357520">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.beans.PropertyChangeEvent;¶¶¶public abstract class AMapReduceTracer {¶	public static String INFO_PREFIX = "";¶	public static String WAIT = "wait";¶	public static String NOTIFY = "notify";¶	public static String ENQUEUE = "enqueue:";¶	public static String DEQUEUE = "dequeue:";¶	public static String ADD = "add:";¶	public static String REDUCE = "reduce:";¶	public static String NEW_MAPPER = "new mapper:";¶	public static String MODEL = "Model"; // value returned by toString() method of model¶	public static String VIEW = "View"; // value returned by toString() method of view¶	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller¶	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer¶	public static final String QUIT = "quit";¶	public static final String EXIT = "exit";¶¶	public static final String QUITTING = "Quitting";¶	public static final String REGISTER = "Register:";¶	public static final String CLIENT_ASSIGNED = "Client Assigned:";¶¶	public static final String REMOTE_LIST = "Remote List:";¶	public static final String REMOTE_RESULT = "Remote Result:";¶¶¶	public static final String START_TOKEN = "Start";¶	public static final int BUFFER_SIZE = 2;	¶¶¶	// -----------------------------A1 Traces----------------------------------¶	protected String toPrefix() {¶		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";¶	}¶	protected void trace(String aSuffix) {¶		System.out.println(toPrefix() + aSuffix);¶	}¶	/**¶	 * To be called before scanning for input string¶	 */¶	protected void traceNumbersPrompt() {¶		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");¶	}¶	/**¶	 * To be called in the controller and runnable¶	 */¶	protected void traceQuit() {¶		trace (QUITTING);¶	}¶	/**¶	 * To be called in the view at start of call to propertyChange¶	 */¶	protected void tracePropertyChange(PropertyChangeEvent anEvent) {¶		trace(anEvent.toString());¶	}¶	/*¶	 * To be called in the map methods of the mappers before returning¶	 */¶	public void traceMap(Object anInput, Object aKeyValue) {¶		trace (MAP  + anInput + ":" + aKeyValue);		¶	}¶	/*¶	 * To be called in the reducer before returning¶	 */¶	protected void traceReduce(Object aList,  Object aReducedMap) {¶		trace(REDUCE + aList + ":" +  aReducedMap);¶	}¶	/*¶	 * ¶	 */¶	public static void traceMapperChange(Class aClass, Object aNewMapper) {¶		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);¶	}¶	¶	//----------------------------A2 traces -----------------------------------¶	/**¶	 * To be called before scanning for number of threads¶	 */¶	protected void traceThreadPrompt() {¶		trace("Please enter the number of threads");¶	}¶	/**¶	 * To be called before a wait on this¶	 */¶	protected void traceWait() {¶		trace (WAIT);¶	}¶	/**¶	 * To be called before doing a notify on this ¶	 */¶	protected void traceNotify() {¶		trace(NOTIFY);¶	}¶//	/**¶//	 * To be called by a summer slave thread before adding an int to its sublist ¶//	 */¶//	protected void traceAdd(int anInt) {¶//		trace ( ADD + anInt);¶//	}¶	/**¶	 * To be called by a master thread before adding an element to ¶	 * a queue¶	 */¶	protected void traceEnqueueRequest(Object anElement) {¶		trace(ENQUEUE + anElement);¶	}¶	/**¶	 * To be called by a  master thread after adding an object to ¶	 * a queue¶	 */¶	protected void traceEnqueue(Object aQueue) {¶		trace(ENQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread before executing a take from¶	 * queue ¶	 */¶	protected void traceDequeueRequest(Object aQueue) {¶		trace (DEQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread after taking an object from a¶	 * queue ¶	 */¶	protected void traceDequeue(Object anElement) {¶		trace (DEQUEUE + anElement);¶	}¶	¶//	/**¶//	 * To be called in the model at the start of its reduce method	 ¶//	 */¶//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {¶//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);¶//	}¶	¶	¶	/*¶	 * Additions since assignment was last given¶	 */¶	public static final String BARRIER_CREATED = "Barrier Created:";¶	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; ¶	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; ¶	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; ¶	¶	public static final String JOINER_CREATED = "Joiner Created:";¶	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; ¶	public static final String JOINER_WAIT_END = "Joiner Wait End:"; ¶	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; ¶	public static final String JOINER_RELEASE = "Joiner Release:"; 	¶	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; ¶	public static final String MAP = "Map:";¶//	public static final String REDUCE = "Reduce:";¶¶	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";¶	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	¶	¶	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {¶		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		¶	}¶	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	¶	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {¶		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		¶	}¶	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	/*¶	 * Call after changing finished threads in the joiner¶	 */¶	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {¶		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );¶	}¶	/*¶	 * To be printed by thread aThreadNumber¶	 */¶	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {¶		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);¶	}¶	¶	¶	/*¶	 * Call after adding reduced map to final map¶	 */¶	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {¶		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);¶	}¶	¶	//---------------------------A3 Traces--------------------------------------¶	/**¶	 * To be called in the server at the start of its method for registering a client¶	 */¶	protected void traceRegister(Object aClient) {¶		trace (REGISTER + aClient);¶	}¶	/**¶	 * To be called in the server runnable when it is assigned a  client¶	 */¶	protected void traceClientAssignment(Object aClient) {¶		trace(CLIENT_ASSIGNED + aClient);¶	}	¶	¶	/**¶	 * To be called in the server runnable before invoking the callback in the client.¶	 * To be also called in the client at the start of its callback to process sublist	 * ¶	 */¶	public void traceRemoteList (Object aSublist) {¶		trace (REMOTE_LIST + aSublist);¶	}¶	/**¶	 * To be called in the client before returning its result.¶	 * To be also called in server runnable after receiving the result from the client¶	 */¶	public void traceRemoteResult (Object aResult) {¶		trace (REMOTE_RESULT + aResult);¶	}¶	/**¶	 * Static method be called by the client main method¶	 */¶	public static void traceExit(Class aClass) {¶		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);¶	}¶	¶	/**¶	 * Slave runnables and client objects can define the following two methods¶	 */¶	public synchronized void synchronizedNotify() {¶		traceNotify();¶		this.notify();¶	}	¶	public synchronized void synchronizedWait() throws InterruptedException {¶		traceWait();		¶		this.wait();¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="279" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:16 EDT 2020" starttimestamp="1591841234468" timestamp="362470" />
  <Command __id="281" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:13:17 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="363191" />
  <Command __id="282" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:18 EDT 2020" starttimestamp="1591841234468" timestamp="364125" />
  <Command __id="283" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:18 EDT 2020" starttimestamp="1591841234468" timestamp="364444" />
  <Command __id="284" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:20 EDT 2020" starttimestamp="1591841234468" timestamp="366060" />
  <Command __id="285" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:13:20 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="366384" />
  <Command __id="286" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:20 EDT 2020" starttimestamp="1591841234468" timestamp="366432" />
  <Command __id="287" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:20 EDT 2020" starttimestamp="1591841234468" timestamp="366434" />
  <Command __id="288" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:21 EDT 2020" starttimestamp="1591841234468" timestamp="366725" />
  <Command __id="289" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:21 EDT 2020" starttimestamp="1591841234468" timestamp="366934" />
  <Command __id="290" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:21 EDT 2020" starttimestamp="1591841234468" timestamp="367071" />
  <Command __id="291" _type="ShellCommand" date="Wed Jun 10 22:13:21 EDT 2020" starttimestamp="1591841234468" timestamp="367097" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="292" _type="ShellCommand" date="Wed Jun 10 22:13:21 EDT 2020" starttimestamp="1591841234468" timestamp="367276" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="293" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:13:21 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="367307" />
  <Command __id="295" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:13:21 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="367332" />
  <Command __id="296" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:13:22 EDT 2020" starttimestamp="1591841234468" timestamp="367556" />
  <Command __id="297" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:22 EDT 2020" starttimestamp="1591841234468" timestamp="368469" />
  <Command __id="298" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:23 EDT 2020" starttimestamp="1591841234468" timestamp="368559" />
  <Command __id="300" _type="MoveCaretCommand" caretOffset="284" date="Wed Jun 10 22:13:23 EDT 2020" docOffset="284" starttimestamp="1591841234468" timestamp="369099" />
  <Command __id="302" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:13:24 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="370020" />
  <Command __id="303" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:25 EDT 2020" starttimestamp="1591841234468" timestamp="370853" />
  <Command __id="304" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:13:25 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="371198" />
  <Command __id="305" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:25 EDT 2020" starttimestamp="1591841234468" timestamp="371231" />
  <Command __id="306" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:25 EDT 2020" starttimestamp="1591841234468" timestamp="371232" />
  <Command __id="307" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:26 EDT 2020" starttimestamp="1591841234468" timestamp="371540" />
  <Command __id="308" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:26 EDT 2020" starttimestamp="1591841234468" timestamp="371762" />
  <Command __id="309" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:26 EDT 2020" starttimestamp="1591841234468" timestamp="371887" />
  <Command __id="310" _type="ShellCommand" date="Wed Jun 10 22:13:26 EDT 2020" starttimestamp="1591841234468" timestamp="371923" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="311" _type="ShellCommand" date="Wed Jun 10 22:13:26 EDT 2020" starttimestamp="1591841234468" timestamp="372065" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="312" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:13:26 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="372090" />
  <Command __id="314" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:13:26 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="372141" />
  <Command __id="315" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:13:26 EDT 2020" starttimestamp="1591841234468" timestamp="372400" />
  <Command __id="316" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:27 EDT 2020" starttimestamp="1591841234468" timestamp="373203" />
  <Command __id="317" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:27 EDT 2020" starttimestamp="1591841234468" timestamp="373281" />
  <Command __id="319" _type="MoveCaretCommand" caretOffset="284" date="Wed Jun 10 22:13:28 EDT 2020" docOffset="284" starttimestamp="1591841234468" timestamp="373986" />
  <Command __id="321" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:13:29 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="374842" />
  <Command __id="322" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:30 EDT 2020" starttimestamp="1591841234468" timestamp="375548" />
  <Command __id="323" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:13:30 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="375872" />
  <Command __id="324" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:30 EDT 2020" starttimestamp="1591841234468" timestamp="375927" />
  <Command __id="325" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:30 EDT 2020" starttimestamp="1591841234468" timestamp="375929" />
  <Command __id="326" _type="ShellCommand" date="Wed Jun 10 22:13:31 EDT 2020" starttimestamp="1591841234468" timestamp="376705" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="327" _type="ShellCommand" date="Wed Jun 10 22:13:31 EDT 2020" starttimestamp="1591841234468" timestamp="376870" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="328" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:13:31 EDT 2020" start_end="END" starttimestamp="1591841234468" timestamp="376900" />
  <Command __id="330" _type="SelectTextCommand" caretOffset="11" date="Wed Jun 10 22:13:31 EDT 2020" end="11" start="8" starttimestamp="1591841234468" timestamp="376931" />
  <Command __id="331" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jun 10 22:13:31 EDT 2020" starttimestamp="1591841234468" timestamp="377271" />
  <Command __id="332" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:32 EDT 2020" starttimestamp="1591841234468" timestamp="378013" />
  <Command __id="333" _type="EclipseCommand" commandID="" date="Wed Jun 10 22:13:32 EDT 2020" starttimestamp="1591841234468" timestamp="378108" />
  <Command __id="335" _type="MoveCaretCommand" caretOffset="284" date="Wed Jun 10 22:13:33 EDT 2020" docOffset="284" starttimestamp="1591841234468" timestamp="378788" />
  <Command __id="337" _type="MoveCaretCommand" caretOffset="0" date="Wed Jun 10 22:13:34 EDT 2020" docOffset="0" starttimestamp="1591841234468" timestamp="379559" />
  <Command __id="338" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Wed Jun 10 22:13:34 EDT 2020" starttimestamp="1591841234468" timestamp="380430" />
  <Command __id="339" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Wed Jun 10 22:13:35 EDT 2020" start_end="START" starttimestamp="1591841234468" timestamp="380747" />
  <Command __id="340" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" date="Wed Jun 10 22:13:35 EDT 2020" starttimestamp="1591841234468" timestamp="380786" />
  <Command __id="264" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:13 EDT 2020" docASTNodeCount="30" docActiveCodeLength="201" docExpressionCount="15" docLength="201" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="359168">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\ReadMaster.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;
import java.util.concurrent.ArrayBlockingQueue;

public interface ReadMaster {
	public void finishRead(Message message);
	public ArrayBlockingQueue<Message> getBufferQueue();
}
]]></snapshot>
  </Command>
  <DocumentChange __id="273" _type="Replace" date="Wed Jun 10 22:13:15 EDT 2020" docASTNodeCount="30" docActiveCodeLength="197" docExpressionCount="15" docLength="197" endLine="0" insertionLength="3" int_docASTNodeCount="28" int_docActiveCodeLength="194" int_docExpressionCount="14" int_docLength="194" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="361295">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="276" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:16 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="361999">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.beans.PropertyChangeEvent;¶¶¶public abstract class AMapReduceTracer {¶	public static String INFO_PREFIX = "";¶	public static String WAIT = "wait";¶	public static String NOTIFY = "notify";¶	public static String ENQUEUE = "enqueue:";¶	public static String DEQUEUE = "dequeue:";¶	public static String ADD = "add:";¶	public static String REDUCE = "reduce:";¶	public static String NEW_MAPPER = "new mapper:";¶	public static String MODEL = "Model"; // value returned by toString() method of model¶	public static String VIEW = "View"; // value returned by toString() method of view¶	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller¶	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer¶	public static final String QUIT = "quit";¶	public static final String EXIT = "exit";¶¶	public static final String QUITTING = "Quitting";¶	public static final String REGISTER = "Register:";¶	public static final String CLIENT_ASSIGNED = "Client Assigned:";¶¶	public static final String REMOTE_LIST = "Remote List:";¶	public static final String REMOTE_RESULT = "Remote Result:";¶¶¶	public static final String START_TOKEN = "Start";¶	public static final int BUFFER_SIZE = 2;	¶¶¶	// -----------------------------A1 Traces----------------------------------¶	protected String toPrefix() {¶		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";¶	}¶	protected void trace(String aSuffix) {¶		System.out.println(toPrefix() + aSuffix);¶	}¶	/**¶	 * To be called before scanning for input string¶	 */¶	protected void traceNumbersPrompt() {¶		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");¶	}¶	/**¶	 * To be called in the controller and runnable¶	 */¶	protected void traceQuit() {¶		trace (QUITTING);¶	}¶	/**¶	 * To be called in the view at start of call to propertyChange¶	 */¶	protected void tracePropertyChange(PropertyChangeEvent anEvent) {¶		trace(anEvent.toString());¶	}¶	/*¶	 * To be called in the map methods of the mappers before returning¶	 */¶	public void traceMap(Object anInput, Object aKeyValue) {¶		trace (MAP  + anInput + ":" + aKeyValue);		¶	}¶	/*¶	 * To be called in the reducer before returning¶	 */¶	protected void traceReduce(Object aList,  Object aReducedMap) {¶		trace(REDUCE + aList + ":" +  aReducedMap);¶	}¶	/*¶	 * ¶	 */¶	public static void traceMapperChange(Class aClass, Object aNewMapper) {¶		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);¶	}¶	¶	//----------------------------A2 traces -----------------------------------¶	/**¶	 * To be called before scanning for number of threads¶	 */¶	protected void traceThreadPrompt() {¶		trace("Please enter the number of threads");¶	}¶	/**¶	 * To be called before a wait on this¶	 */¶	protected void traceWait() {¶		trace (WAIT);¶	}¶	/**¶	 * To be called before doing a notify on this ¶	 */¶	protected void traceNotify() {¶		trace(NOTIFY);¶	}¶//	/**¶//	 * To be called by a summer slave thread before adding an int to its sublist ¶//	 */¶//	protected void traceAdd(int anInt) {¶//		trace ( ADD + anInt);¶//	}¶	/**¶	 * To be called by a master thread before adding an element to ¶	 * a queue¶	 */¶	protected void traceEnqueueRequest(Object anElement) {¶		trace(ENQUEUE + anElement);¶	}¶	/**¶	 * To be called by a  master thread after adding an object to ¶	 * a queue¶	 */¶	protected void traceEnqueue(Object aQueue) {¶		trace(ENQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread before executing a take from¶	 * queue ¶	 */¶	protected void traceDequeueRequest(Object aQueue) {¶		trace (DEQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread after taking an object from a¶	 * queue ¶	 */¶	protected void traceDequeue(Object anElement) {¶		trace (DEQUEUE + anElement);¶	}¶	¶//	/**¶//	 * To be called in the model at the start of its reduce method	 ¶//	 */¶//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {¶//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);¶//	}¶	¶	¶	/*¶	 * Additions since assignment was last given¶	 */¶	public static final String BARRIER_CREATED = "Barrier Created:";¶	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; ¶	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; ¶	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; ¶	¶	public static final String JOINER_CREATED = "Joiner Created:";¶	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; ¶	public static final String JOINER_WAIT_END = "Joiner Wait End:"; ¶	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; ¶	public static final String JOINER_RELEASE = "Joiner Release:"; 	¶	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; ¶	public static final String MAP = "Map:";¶//	public static final String REDUCE = "Reduce:";¶¶	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";¶	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	¶	¶	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {¶		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		¶	}¶	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	¶	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {¶		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		¶	}¶	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	/*¶	 * Call after changing finished threads in the joiner¶	 */¶	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {¶		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );¶	}¶	/*¶	 * To be printed by thread aThreadNumber¶	 */¶	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {¶		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);¶	}¶	¶	¶	/*¶	 * Call after adding reduced map to final map¶	 */¶	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {¶		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);¶	}¶	¶	//---------------------------A3 Traces--------------------------------------¶	/**¶	 * To be called in the server at the start of its method for registering a client¶	 */¶	protected void traceRegister(Object aClient) {¶		trace (REGISTER + aClient);¶	}¶	/**¶	 * To be called in the server runnable when it is assigned a  client¶	 */¶	protected void traceClientAssignment(Object aClient) {¶		trace(CLIENT_ASSIGNED + aClient);¶	}	¶	¶	/**¶	 * To be called in the server runnable before invoking the callback in the client.¶	 * To be also called in the client at the start of its callback to process sublist	 * ¶	 */¶	public void traceRemoteList (Object aSublist) {¶		trace (REMOTE_LIST + aSublist);¶	}¶	/**¶	 * To be called in the client before returning its result.¶	 * To be also called in server runnable after receiving the result from the client¶	 */¶	public void traceRemoteResult (Object aResult) {¶		trace (REMOTE_RESULT + aResult);¶	}¶	/**¶	 * Static method be called by the client main method¶	 */¶	public static void traceExit(Class aClass) {¶		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);¶	}¶	¶	/**¶	 * Slave runnables and client objects can define the following two methods¶	 */¶	public synchronized void synchronizedNotify() {¶		traceNotify();¶		this.notify();¶	}	¶	public synchronized void synchronizedWait() throws InterruptedException {¶		traceWait();		¶		this.wait();¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="280" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:17 EDT 2020" docASTNodeCount="85" docActiveCodeLength="526" docExpressionCount="46" docLength="526" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="362936">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\ReadSlave.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import java.util.concurrent.ArrayBlockingQueue;

public class ReadSlave implements Runnable{
	
	private ArrayBlockingQueue<Message> bufferQueue;
	ReadMaster master;
	public ReadSlave(ReadMaster master) {
		this.master = master;
		bufferQueue = master.getBufferQueue();
	}
	
	@Override
	public void run() {
		try {
			while(true) {
				Message message = bufferQueue.take();
				master.finishRead(message);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
}
]]></snapshot>
  </Command>
  <DocumentChange __id="294" _type="Replace" date="Wed Jun 10 22:13:21 EDT 2020" docASTNodeCount="85" docActiveCodeLength="522" docExpressionCount="46" docLength="522" endLine="0" insertionLength="3" int_docASTNodeCount="83" int_docActiveCodeLength="519" int_docExpressionCount="45" int_docLength="519" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="367310">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="299" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:23 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="368807">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.beans.PropertyChangeEvent;¶¶¶public abstract class AMapReduceTracer {¶	public static String INFO_PREFIX = "";¶	public static String WAIT = "wait";¶	public static String NOTIFY = "notify";¶	public static String ENQUEUE = "enqueue:";¶	public static String DEQUEUE = "dequeue:";¶	public static String ADD = "add:";¶	public static String REDUCE = "reduce:";¶	public static String NEW_MAPPER = "new mapper:";¶	public static String MODEL = "Model"; // value returned by toString() method of model¶	public static String VIEW = "View"; // value returned by toString() method of view¶	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller¶	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer¶	public static final String QUIT = "quit";¶	public static final String EXIT = "exit";¶¶	public static final String QUITTING = "Quitting";¶	public static final String REGISTER = "Register:";¶	public static final String CLIENT_ASSIGNED = "Client Assigned:";¶¶	public static final String REMOTE_LIST = "Remote List:";¶	public static final String REMOTE_RESULT = "Remote Result:";¶¶¶	public static final String START_TOKEN = "Start";¶	public static final int BUFFER_SIZE = 2;	¶¶¶	// -----------------------------A1 Traces----------------------------------¶	protected String toPrefix() {¶		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";¶	}¶	protected void trace(String aSuffix) {¶		System.out.println(toPrefix() + aSuffix);¶	}¶	/**¶	 * To be called before scanning for input string¶	 */¶	protected void traceNumbersPrompt() {¶		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");¶	}¶	/**¶	 * To be called in the controller and runnable¶	 */¶	protected void traceQuit() {¶		trace (QUITTING);¶	}¶	/**¶	 * To be called in the view at start of call to propertyChange¶	 */¶	protected void tracePropertyChange(PropertyChangeEvent anEvent) {¶		trace(anEvent.toString());¶	}¶	/*¶	 * To be called in the map methods of the mappers before returning¶	 */¶	public void traceMap(Object anInput, Object aKeyValue) {¶		trace (MAP  + anInput + ":" + aKeyValue);		¶	}¶	/*¶	 * To be called in the reducer before returning¶	 */¶	protected void traceReduce(Object aList,  Object aReducedMap) {¶		trace(REDUCE + aList + ":" +  aReducedMap);¶	}¶	/*¶	 * ¶	 */¶	public static void traceMapperChange(Class aClass, Object aNewMapper) {¶		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);¶	}¶	¶	//----------------------------A2 traces -----------------------------------¶	/**¶	 * To be called before scanning for number of threads¶	 */¶	protected void traceThreadPrompt() {¶		trace("Please enter the number of threads");¶	}¶	/**¶	 * To be called before a wait on this¶	 */¶	protected void traceWait() {¶		trace (WAIT);¶	}¶	/**¶	 * To be called before doing a notify on this ¶	 */¶	protected void traceNotify() {¶		trace(NOTIFY);¶	}¶//	/**¶//	 * To be called by a summer slave thread before adding an int to its sublist ¶//	 */¶//	protected void traceAdd(int anInt) {¶//		trace ( ADD + anInt);¶//	}¶	/**¶	 * To be called by a master thread before adding an element to ¶	 * a queue¶	 */¶	protected void traceEnqueueRequest(Object anElement) {¶		trace(ENQUEUE + anElement);¶	}¶	/**¶	 * To be called by a  master thread after adding an object to ¶	 * a queue¶	 */¶	protected void traceEnqueue(Object aQueue) {¶		trace(ENQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread before executing a take from¶	 * queue ¶	 */¶	protected void traceDequeueRequest(Object aQueue) {¶		trace (DEQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread after taking an object from a¶	 * queue ¶	 */¶	protected void traceDequeue(Object anElement) {¶		trace (DEQUEUE + anElement);¶	}¶	¶//	/**¶//	 * To be called in the model at the start of its reduce method	 ¶//	 */¶//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {¶//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);¶//	}¶	¶	¶	/*¶	 * Additions since assignment was last given¶	 */¶	public static final String BARRIER_CREATED = "Barrier Created:";¶	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; ¶	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; ¶	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; ¶	¶	public static final String JOINER_CREATED = "Joiner Created:";¶	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; ¶	public static final String JOINER_WAIT_END = "Joiner Wait End:"; ¶	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; ¶	public static final String JOINER_RELEASE = "Joiner Release:"; 	¶	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; ¶	public static final String MAP = "Map:";¶//	public static final String REDUCE = "Reduce:";¶¶	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";¶	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	¶	¶	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {¶		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		¶	}¶	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	¶	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {¶		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		¶	}¶	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	/*¶	 * Call after changing finished threads in the joiner¶	 */¶	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {¶		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );¶	}¶	/*¶	 * To be printed by thread aThreadNumber¶	 */¶	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {¶		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);¶	}¶	¶	¶	/*¶	 * Call after adding reduced map to final map¶	 */¶	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {¶		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);¶	}¶	¶	//---------------------------A3 Traces--------------------------------------¶	/**¶	 * To be called in the server at the start of its method for registering a client¶	 */¶	protected void traceRegister(Object aClient) {¶		trace (REGISTER + aClient);¶	}¶	/**¶	 * To be called in the server runnable when it is assigned a  client¶	 */¶	protected void traceClientAssignment(Object aClient) {¶		trace(CLIENT_ASSIGNED + aClient);¶	}	¶	¶	/**¶	 * To be called in the server runnable before invoking the callback in the client.¶	 * To be also called in the client at the start of its callback to process sublist	 * ¶	 */¶	public void traceRemoteList (Object aSublist) {¶		trace (REMOTE_LIST + aSublist);¶	}¶	/**¶	 * To be called in the client before returning its result.¶	 * To be also called in server runnable after receiving the result from the client¶	 */¶	public void traceRemoteResult (Object aResult) {¶		trace (REMOTE_RESULT + aResult);¶	}¶	/**¶	 * Static method be called by the client main method¶	 */¶	public static void traceExit(Class aClass) {¶		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);¶	}¶	¶	/**¶	 * Slave runnables and client objects can define the following two methods¶	 */¶	public synchronized void synchronizedNotify() {¶		traceNotify();¶		this.notify();¶	}	¶	public synchronized void synchronizedWait() throws InterruptedException {¶		traceWait();		¶		this.wait();¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="301" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:24 EDT 2020" docASTNodeCount="50" docActiveCodeLength="306" docExpressionCount="35" docLength="306" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="369850">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\SimulationClient.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import util.annotations.Tags;
import util.tags.DistributedTags;

@Tags({DistributedTags.CLIENT, DistributedTags.RMI, DistributedTags.GIPC, DistributedTags.NIO})
public class SimulationClient {
	public static void main(String args[]) {
		new HalloweenClient().start(args);
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="313" _type="Replace" date="Wed Jun 10 22:13:26 EDT 2020" docASTNodeCount="50" docActiveCodeLength="302" docExpressionCount="35" docLength="302" endLine="0" insertionLength="3" int_docASTNodeCount="48" int_docActiveCodeLength="299" int_docExpressionCount="34" int_docLength="299" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="372097">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="318" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:28 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="373724">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.beans.PropertyChangeEvent;¶¶¶public abstract class AMapReduceTracer {¶	public static String INFO_PREFIX = "";¶	public static String WAIT = "wait";¶	public static String NOTIFY = "notify";¶	public static String ENQUEUE = "enqueue:";¶	public static String DEQUEUE = "dequeue:";¶	public static String ADD = "add:";¶	public static String REDUCE = "reduce:";¶	public static String NEW_MAPPER = "new mapper:";¶	public static String MODEL = "Model"; // value returned by toString() method of model¶	public static String VIEW = "View"; // value returned by toString() method of view¶	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller¶	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer¶	public static final String QUIT = "quit";¶	public static final String EXIT = "exit";¶¶	public static final String QUITTING = "Quitting";¶	public static final String REGISTER = "Register:";¶	public static final String CLIENT_ASSIGNED = "Client Assigned:";¶¶	public static final String REMOTE_LIST = "Remote List:";¶	public static final String REMOTE_RESULT = "Remote Result:";¶¶¶	public static final String START_TOKEN = "Start";¶	public static final int BUFFER_SIZE = 2;	¶¶¶	// -----------------------------A1 Traces----------------------------------¶	protected String toPrefix() {¶		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";¶	}¶	protected void trace(String aSuffix) {¶		System.out.println(toPrefix() + aSuffix);¶	}¶	/**¶	 * To be called before scanning for input string¶	 */¶	protected void traceNumbersPrompt() {¶		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");¶	}¶	/**¶	 * To be called in the controller and runnable¶	 */¶	protected void traceQuit() {¶		trace (QUITTING);¶	}¶	/**¶	 * To be called in the view at start of call to propertyChange¶	 */¶	protected void tracePropertyChange(PropertyChangeEvent anEvent) {¶		trace(anEvent.toString());¶	}¶	/*¶	 * To be called in the map methods of the mappers before returning¶	 */¶	public void traceMap(Object anInput, Object aKeyValue) {¶		trace (MAP  + anInput + ":" + aKeyValue);		¶	}¶	/*¶	 * To be called in the reducer before returning¶	 */¶	protected void traceReduce(Object aList,  Object aReducedMap) {¶		trace(REDUCE + aList + ":" +  aReducedMap);¶	}¶	/*¶	 * ¶	 */¶	public static void traceMapperChange(Class aClass, Object aNewMapper) {¶		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);¶	}¶	¶	//----------------------------A2 traces -----------------------------------¶	/**¶	 * To be called before scanning for number of threads¶	 */¶	protected void traceThreadPrompt() {¶		trace("Please enter the number of threads");¶	}¶	/**¶	 * To be called before a wait on this¶	 */¶	protected void traceWait() {¶		trace (WAIT);¶	}¶	/**¶	 * To be called before doing a notify on this ¶	 */¶	protected void traceNotify() {¶		trace(NOTIFY);¶	}¶//	/**¶//	 * To be called by a summer slave thread before adding an int to its sublist ¶//	 */¶//	protected void traceAdd(int anInt) {¶//		trace ( ADD + anInt);¶//	}¶	/**¶	 * To be called by a master thread before adding an element to ¶	 * a queue¶	 */¶	protected void traceEnqueueRequest(Object anElement) {¶		trace(ENQUEUE + anElement);¶	}¶	/**¶	 * To be called by a  master thread after adding an object to ¶	 * a queue¶	 */¶	protected void traceEnqueue(Object aQueue) {¶		trace(ENQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread before executing a take from¶	 * queue ¶	 */¶	protected void traceDequeueRequest(Object aQueue) {¶		trace (DEQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread after taking an object from a¶	 * queue ¶	 */¶	protected void traceDequeue(Object anElement) {¶		trace (DEQUEUE + anElement);¶	}¶	¶//	/**¶//	 * To be called in the model at the start of its reduce method	 ¶//	 */¶//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {¶//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);¶//	}¶	¶	¶	/*¶	 * Additions since assignment was last given¶	 */¶	public static final String BARRIER_CREATED = "Barrier Created:";¶	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; ¶	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; ¶	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; ¶	¶	public static final String JOINER_CREATED = "Joiner Created:";¶	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; ¶	public static final String JOINER_WAIT_END = "Joiner Wait End:"; ¶	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; ¶	public static final String JOINER_RELEASE = "Joiner Release:"; 	¶	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; ¶	public static final String MAP = "Map:";¶//	public static final String REDUCE = "Reduce:";¶¶	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";¶	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	¶	¶	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {¶		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		¶	}¶	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	¶	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {¶		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		¶	}¶	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	/*¶	 * Call after changing finished threads in the joiner¶	 */¶	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {¶		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );¶	}¶	/*¶	 * To be printed by thread aThreadNumber¶	 */¶	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {¶		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);¶	}¶	¶	¶	/*¶	 * Call after adding reduced map to final map¶	 */¶	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {¶		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);¶	}¶	¶	//---------------------------A3 Traces--------------------------------------¶	/**¶	 * To be called in the server at the start of its method for registering a client¶	 */¶	protected void traceRegister(Object aClient) {¶		trace (REGISTER + aClient);¶	}¶	/**¶	 * To be called in the server runnable when it is assigned a  client¶	 */¶	protected void traceClientAssignment(Object aClient) {¶		trace(CLIENT_ASSIGNED + aClient);¶	}	¶	¶	/**¶	 * To be called in the server runnable before invoking the callback in the client.¶	 * To be also called in the client at the start of its callback to process sublist	 * ¶	 */¶	public void traceRemoteList (Object aSublist) {¶		trace (REMOTE_LIST + aSublist);¶	}¶	/**¶	 * To be called in the client before returning its result.¶	 * To be also called in server runnable after receiving the result from the client¶	 */¶	public void traceRemoteResult (Object aResult) {¶		trace (REMOTE_RESULT + aResult);¶	}¶	/**¶	 * Static method be called by the client main method¶	 */¶	public static void traceExit(Class aClass) {¶		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);¶	}¶	¶	/**¶	 * Slave runnables and client objects can define the following two methods¶	 */¶	public synchronized void synchronizedNotify() {¶		traceNotify();¶		this.notify();¶	}	¶	public synchronized void synchronizedWait() throws InterruptedException {¶		traceWait();		¶		this.wait();¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="320" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:29 EDT 2020" docASTNodeCount="221" docActiveCodeLength="1303" docExpressionCount="164" docLength="1303" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="374665">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\SimulationRegistry.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;
import java.rmi.registry.LocateRegistry;
import java.util.Scanner;

import assignments.util.mainArgs.RegistryArgsProcessor;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.PortTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.rmi.RMIRegistryCreated;
import util.trace.port.rpc.rmi.RMITraceUtility;

@Tags({DistributedTags.REGISTRY, DistributedTags.RMI})
public class SimulationRegistry {
	private int port;
	public static void main(String args[]) {
		new SimulationRegistry().start(args);
	}
	
	public void start(String args[]) {
		Scanner scanner = new Scanner(System.in);
		port = RegistryArgsProcessor.getRegistryPort(args);
		PortTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		
		FactoryTraceUtility.setTracing();		
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		try {
			RMIRegistryCreated.newCase(this, port);
			LocateRegistry.createRegistry(port);
			scanner.nextLine();
		} catch (Exception e) {
			e.printStackTrace();
		}
		scanner.close();
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="329" _type="Replace" date="Wed Jun 10 22:13:31 EDT 2020" docASTNodeCount="221" docActiveCodeLength="1299" docExpressionCount="164" docLength="1299" endLine="0" insertionLength="3" int_docASTNodeCount="219" int_docActiveCodeLength="1296" int_docExpressionCount="163" int_docLength="1296" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="376905">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
  <Command __id="334" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:33 EDT 2020" docASTNodeCount="932" docActiveCodeLength="6392" docExpressionCount="458" docLength="8987" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="378588">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\AMapReduceTracer.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package com;¶¶import java.beans.PropertyChangeEvent;¶¶¶public abstract class AMapReduceTracer {¶	public static String INFO_PREFIX = "";¶	public static String WAIT = "wait";¶	public static String NOTIFY = "notify";¶	public static String ENQUEUE = "enqueue:";¶	public static String DEQUEUE = "dequeue:";¶	public static String ADD = "add:";¶	public static String REDUCE = "reduce:";¶	public static String NEW_MAPPER = "new mapper:";¶	public static String MODEL = "Model"; // value returned by toString() method of model¶	public static String VIEW = "View"; // value returned by toString() method of view¶	public static String CONTROLLER = "Controller"; // value returned by toString() method of controller¶	public static String SLAVE = "Slave"; // value returned by toString() method of slave summer¶	public static final String QUIT = "quit";¶	public static final String EXIT = "exit";¶¶	public static final String QUITTING = "Quitting";¶	public static final String REGISTER = "Register:";¶	public static final String CLIENT_ASSIGNED = "Client Assigned:";¶¶	public static final String REMOTE_LIST = "Remote List:";¶	public static final String REMOTE_RESULT = "Remote Result:";¶¶¶	public static final String START_TOKEN = "Start";¶	public static final int BUFFER_SIZE = 2;	¶¶¶	// -----------------------------A1 Traces----------------------------------¶	protected String toPrefix() {¶		return INFO_PREFIX + Thread.currentThread() + ":" + this + ":";¶	}¶	protected void trace(String aSuffix) {¶		System.out.println(toPrefix() + aSuffix);¶	}¶	/**¶	 * To be called before scanning for input string¶	 */¶	protected void traceNumbersPrompt() {¶		trace ("Please enter " + QUIT + " or a line of tokens to be processed separated by spaces");¶	}¶	/**¶	 * To be called in the controller and runnable¶	 */¶	protected void traceQuit() {¶		trace (QUITTING);¶	}¶	/**¶	 * To be called in the view at start of call to propertyChange¶	 */¶	protected void tracePropertyChange(PropertyChangeEvent anEvent) {¶		trace(anEvent.toString());¶	}¶	/*¶	 * To be called in the map methods of the mappers before returning¶	 */¶	public void traceMap(Object anInput, Object aKeyValue) {¶		trace (MAP  + anInput + ":" + aKeyValue);		¶	}¶	/*¶	 * To be called in the reducer before returning¶	 */¶	protected void traceReduce(Object aList,  Object aReducedMap) {¶		trace(REDUCE + aList + ":" +  aReducedMap);¶	}¶	/*¶	 * ¶	 */¶	public static void traceMapperChange(Class aClass, Object aNewMapper) {¶		System.out.println(INFO_PREFIX + Thread.currentThread() + ":" + aClass + ":" + NEW_MAPPER +  aNewMapper);¶	}¶	¶	//----------------------------A2 traces -----------------------------------¶	/**¶	 * To be called before scanning for number of threads¶	 */¶	protected void traceThreadPrompt() {¶		trace("Please enter the number of threads");¶	}¶	/**¶	 * To be called before a wait on this¶	 */¶	protected void traceWait() {¶		trace (WAIT);¶	}¶	/**¶	 * To be called before doing a notify on this ¶	 */¶	protected void traceNotify() {¶		trace(NOTIFY);¶	}¶//	/**¶//	 * To be called by a summer slave thread before adding an int to its sublist ¶//	 */¶//	protected void traceAdd(int anInt) {¶//		trace ( ADD + anInt);¶//	}¶	/**¶	 * To be called by a master thread before adding an element to ¶	 * a queue¶	 */¶	protected void traceEnqueueRequest(Object anElement) {¶		trace(ENQUEUE + anElement);¶	}¶	/**¶	 * To be called by a  master thread after adding an object to ¶	 * a queue¶	 */¶	protected void traceEnqueue(Object aQueue) {¶		trace(ENQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread before executing a take from¶	 * queue ¶	 */¶	protected void traceDequeueRequest(Object aQueue) {¶		trace (DEQUEUE + aQueue);¶	}¶	/**¶	 * To be called by a slave thread after taking an object from a¶	 * queue ¶	 */¶	protected void traceDequeue(Object anElement) {¶		trace (DEQUEUE + anElement);¶	}¶	¶//	/**¶//	 * To be called in the model at the start of its reduce method	 ¶//	 */¶//	protected void traceReduce(int aNumItemsReduced, Object aReducedMap) {¶//		trace(REDUCE + aNumItemsReduced + ":" + aReducedMap);¶//	}¶	¶	¶	/*¶	 * Additions since assignment was last given¶	 */¶	public static final String BARRIER_CREATED = "Barrier Created:";¶	public static final String BARRIER_WAIT_START = "Barrier Wait Start:"; ¶	public static final String BARRIER_WAIT_END = "Barrier Wait End:"; ¶	public static final String BARRIER_RELEASE_ALL = "Barrier Release All:"; ¶	¶	public static final String JOINER_CREATED = "Joiner Created:";¶	public static final String JOINER_WAIT_START = "Joiner Wait Start:"; ¶	public static final String JOINER_WAIT_END = "Joiner Wait End:"; ¶	public static final String JOINER_FINISHED_TASK = "Joiner Finished:"; ¶	public static final String JOINER_RELEASE = "Joiner Release:"; 	¶	public static final String PARTITION_ASSIGNED = "Partition Assigned:"; ¶	public static final String MAP = "Map:";¶//	public static final String REDUCE = "Reduce:";¶¶	public static final String PARTITION_AFTER_BARRIER = "Partition After Barrier:";¶	public static final String ADDED_TO_FINAL_MAP = "Added to Final Map:";	¶	¶	public void traceBarrierCreated(Object aBarrier, int aNumThreads) {¶		trace (BARRIER_CREATED  + aBarrier + ":" + aNumThreads);		¶	}¶	public void traceBarrierWaitStart(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_START + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierWaitEnd(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_WAIT_END + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	public void traceBarrierReleaseAll(Object aBarrier, int aNumThreads, int aNumWaitingThreads) {¶		trace (BARRIER_RELEASE_ALL + aBarrier + ":" + aNumThreads + ":" + aNumWaitingThreads);		¶	}¶	¶	public void traceJoinerCreated(Object aJoiner, int aNumThreads) {¶		trace (JOINER_CREATED +aJoiner + ":" + aNumThreads);		¶	}¶	public void traceJoinerWaitStart(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_START + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerWaitEnd(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_WAIT_END + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	/*¶	 * Call after changing finished threads in the joiner¶	 */¶	public void traceJoinerFinishedTask(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_FINISHED_TASK + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void traceJoinerRelease(Object aJoiner, int aNumThreads, int aNumFinishedThreads) {¶		trace (JOINER_RELEASE + aJoiner + ":" + aNumThreads + ":" + aNumFinishedThreads);		¶	}¶	public void tracePartitionAssigned(Object aKey, Object aValue, int aPartitionNum, int aNumPartitions ) {¶		trace (PARTITION_ASSIGNED + aKey + ":" + aValue + ":" + aPartitionNum + ":" + aNumPartitions );¶	}¶	/*¶	 * To be printed by thread aThreadNumber¶	 */¶	public void traceSplitAfterBarrier(int aThreadNumber, Object aList) {¶		trace (PARTITION_AFTER_BARRIER + aThreadNumber + ":" + aList);¶	}¶	¶	¶	/*¶	 * Call after adding reduced map to final map¶	 */¶	protected void traceAddedToMap(Object anOriginalMap, Object aReducedMap) {¶		trace( ADDED_TO_FINAL_MAP + anOriginalMap + ":" + aReducedMap);¶	}¶	¶	//---------------------------A3 Traces--------------------------------------¶	/**¶	 * To be called in the server at the start of its method for registering a client¶	 */¶	protected void traceRegister(Object aClient) {¶		trace (REGISTER + aClient);¶	}¶	/**¶	 * To be called in the server runnable when it is assigned a  client¶	 */¶	protected void traceClientAssignment(Object aClient) {¶		trace(CLIENT_ASSIGNED + aClient);¶	}	¶	¶	/**¶	 * To be called in the server runnable before invoking the callback in the client.¶	 * To be also called in the client at the start of its callback to process sublist	 * ¶	 */¶	public void traceRemoteList (Object aSublist) {¶		trace (REMOTE_LIST + aSublist);¶	}¶	/**¶	 * To be called in the client before returning its result.¶	 * To be also called in server runnable after receiving the result from the client¶	 */¶	public void traceRemoteResult (Object aResult) {¶		trace (REMOTE_RESULT + aResult);¶	}¶	/**¶	 * Static method be called by the client main method¶	 */¶	public static void traceExit(Class aClass) {¶		System.out.println (INFO_PREFIX + Thread.currentThread() + ":" + EXIT);¶	}¶	¶	/**¶	 * Slave runnables and client objects can define the following two methods¶	 */¶	public synchronized void synchronizedNotify() {¶		traceNotify();¶		this.notify();¶	}	¶	public synchronized void synchronizedWait() throws InterruptedException {¶		traceWait();		¶		this.wait();¶		¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="336" _type="DiffBasedFileOpenCommand" date="Wed Jun 10 22:13:33 EDT 2020" docASTNodeCount="50" docActiveCodeLength="306" docExpressionCount="35" docLength="306" projectName="distributed-framework" starttimestamp="1591841234468" timestamp="379372">
    <filePath><![CDATA[C:\Users\jchen\eclipse-workspace\distributed-framework\src\com\SimulationServer.java]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[package comp533;

import util.annotations.Tags;
import util.tags.DistributedTags;

@Tags({DistributedTags.SERVER, DistributedTags.RMI, DistributedTags.GIPC, DistributedTags.NIO})
public class SimulationServer {
	public static void main(String args[]) {
		new HalloweenServer().start(args);
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="345" _type="Replace" date="Wed Jun 10 22:13:35 EDT 2020" docASTNodeCount="50" docActiveCodeLength="302" docExpressionCount="35" docLength="302" endLine="0" insertionLength="3" int_docASTNodeCount="48" int_docActiveCodeLength="299" int_docExpressionCount="34" int_docLength="299" length="7" offset="8" startLine="0" starttimestamp="1591841234468" timestamp="381461">
    <deletedText><![CDATA[comp533]]></deletedText>
    <insertedText><![CDATA[com]]></insertedText>
  </DocumentChange>
